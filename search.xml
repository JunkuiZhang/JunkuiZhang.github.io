<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>小窝的新生</title>
    <url>/2018/01/03/Hello/</url>
    <content><![CDATA[<h1 id="代码测试">代码测试</h1>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> numpy</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;Hello World!&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h1 id="数学公式测试">数学公式测试</h1>
<p><span class="math display">\[
E = mc^2
\]</span></p>
<h1 id="网页测试">网页测试</h1>
<p>这是个<a href="https://www.baidu.com">网页</a></p>
]]></content>
      <categories>
        <category>测试</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Testing</tag>
      </tags>
  </entry>
  <entry>
    <title>Homebrew的安装</title>
    <url>/2020/06/17/HomeBrewInstall/</url>
    <content><![CDATA[<h1 id="安装">安装</h1>
<p>由于某些原因，官方提供的安装方法会非常慢，因此从Github直接下载源码包，然后再把下载地址替换为国内镜像。</p>
<span id="more"></span>
<h2 id="替换安装地址">替换安装地址</h2>
<p>把<code>install.sh</code>用记事本打开，并把其中的<code>BREW_REPO=</code>的地址改为： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">BREW_REPO=&quot;https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git&quot;</span><br></pre></td></tr></table></figure> 这里用的是清华大学的镜像。</p>
<h2 id="替换其他地址">替换其他地址</h2>
<p>上面仅仅替换了第一步的下载地址，Homebrew还会自动下载brew-core、brew-bottle、brew-cask等内容，而这些内容的下载地址在源文件中本人没有找到，因此要在terminal下载这些内容时，按<code>control+c</code>来中断程序，并手动指定下载地址。</p>
<h3 id="homebrew-core">Homebrew-core</h3>
<p>若卡在： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">==&gt; Tapping homebrew/core</span><br><span class="line">Cloning into &#x27;/usr/local/Homebrew/Library/Taps/homebrew/homebrew-core&#x27;...</span><br></pre></td></tr></table></figure> 或这里下载很慢时，按<code>control+c</code>来中断程序，并输入如下代码： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd &quot;$(brew --repo)/Library/Taps/&quot;</span><br><span class="line">mkdir homebrew &amp;&amp; cd homebrew</span><br><span class="line">git clone git://mirrors.ustc.edu.cn/homebrew-core.git</span><br></pre></td></tr></table></figure> ### Homebrew-cask</p>
<p>在安装cask卡住时，方法同上： <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd &quot;$(brew --repo)/Library/Taps/&quot;</span><br><span class="line">cd homebrew</span><br><span class="line">git clone https://mirrors.ustc.edu.cn/homebrew-cask.git</span><br></pre></td></tr></table></figure></p>
<h2 id="安装成功">安装成功</h2>
<p>之后继续安装，出现<code>==&gt; Installation successful!</code>表明安装成功。</p>
<h1 id="更改源地址">更改源地址</h1>
<p>需要替换brew、brew-core、brew-cask、brew-bottle的地址，以防平时使用时下载速度过慢。</p>
<h2 id="清华大学源">清华大学源</h2>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git -C &quot;$(brew --repo)&quot; remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git</span><br><span class="line"></span><br><span class="line">git -C &quot;$(brew --repo homebrew/core)&quot; remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.git</span><br><span class="line"></span><br><span class="line">git -C &quot;$(brew --repo homebrew/cask)&quot; remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-cask.git</span><br><span class="line"></span><br><span class="line">echo &#x27;export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles&#x27; &gt;&gt; ~/.bash_profile</span><br><span class="line">source ~/.bash_profile</span><br><span class="line"></span><br><span class="line">brew update</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>MacOS</category>
      </categories>
      <tags>
        <tag>Others</tag>
      </tags>
  </entry>
  <entry>
    <title>大糖帝国（The Great Sugar Empire）</title>
    <url>/2019/01/15/New-Society/</url>
    <content><![CDATA[<h1 id="概述">概述</h1>
<h1 id="模型">模型</h1>
<h1 id="附录">附录</h1>
<h2 id="源码">源码</h2>
<p>代码见<a href="https://github.com/JunkuiZhang/NewSociaty/">GitHub</a></p>
<h2 id="基尼系数的计算">基尼系数的计算</h2>
<p>由于这里数据量较小，故可使用直接计算法计算</p>
<p><span class="math display">\[
\Delta = \frac{1}{n^2}\sum^{n}_{j=1}\sum^{n}_{i=1}|Y_j-Y_i|
\]</span></p>
<p>这里<span class="math inline">\(\Delta\)</span>是基尼平均差，<span class="math inline">\(|Y\_j-Y\_i|\)</span>是任意一对样本差的绝对值，<span class="math inline">\(n\)</span>是样本容量</p>
<p>则基尼系数可以计算为：</p>
<p><span class="math display">\[
G = \frac{\Delta}{2u}
\]</span></p>
<p>这里<span class="math inline">\(G\)</span>表示基尼系数，<span class="math inline">\(u\)</span>是样本均值。</p>
]]></content>
      <categories>
        <category>模型</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Economy</tag>
      </tags>
  </entry>
  <entry>
    <title>配置Arch Linux</title>
    <url>/2022/03/16/archlinux-setup/</url>
    <content><![CDATA[<h2 id="引导设置">引导设置</h2>
<p>这部分内容将把Linux暴露给Opencore，以从Opencore直接启动。</p>
<span id="more"></span>
<ol type="1">
<li>通过OC进入Linux</li>
</ol>
<p>开启OC的Openshell，通过执行<code>\EFI\grub_uefi\grubx64.efi</code>来进入linux。</p>
<blockquote>
<p>输入<code>fs0:</code>或者<code>fs1:</code>等进入文件系统， 通过<code>lsblk</code>查看硬盘，一般而言，<code>fs0:</code>是第一个硬盘位，<code>fs1:</code>是第二个硬盘位</p>
</blockquote>
<blockquote>
<p>由于之前执行<code>grub-install</code>时指定了<code>--bootloader-id=grub_uefi</code>因此入口在<code>grub_uefi</code>文件夹下</p>
</blockquote>
<ol start="2" type="1">
<li>生成配置 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> efibootmgr -c -L <span class="string">&quot;Linux&quot;</span> -l <span class="string">&quot;\EFI\grub_uefi\grubx64.efi&quot;</span> -d <span class="string">&quot;/dev/nvme0n1&quot;</span> -p 1</span><br></pre></td></tr></table></figure></li>
</ol>
<ul>
<li><code>-c</code>: Create</li>
<li><code>-L "Linux"</code>: Label the boot entry (you can change it to whatever you want)</li>
<li><code>-l "\EFI\pathto\filex64.efi"</code>: loader file path, must be in a format the UEFI Firmware can use, which means <code>\</code> for pathing instead of <code>/</code> you find in unix</li>
<li><code>-d "/dev/sda"</code>: disk path so that efibootmgr know which disk the UEFI firmware should read the file from, it can be <code>/dev/nvme0nX</code> (with X as a number) if you're using NVMe</li>
<li><code>-p 1</code>: point the partition number we found earlier, in case your EFI partition is the first one, this can be omitted</li>
</ul>
<blockquote>
<p>由于之前执行<code>grub-install</code>时指定<code>--bootloader-id=grub_uefi</code>，因此路径为<code>grub_uefi</code></p>
</blockquote>
<ol start="3" type="1">
<li>重启</li>
</ol>
<p>在Opencore界面会发现一个新的叫<code>EFI</code>的入口，即为该linux。</p>
<h2 id="配置部分软件">配置部分软件</h2>
<h3 id="配置git">配置git</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S git</span><br><span class="line">git config --global user.email <span class="string">&quot;YOUR_EMAIL@SOME.com&quot;</span></span><br><span class="line">git config --global user.name <span class="string">&quot;YOUR NAME&quot;</span></span><br></pre></td></tr></table></figure>
<p>给git配置代理： <figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">git config --global http.proxy http://127.0.0.1:10809</span><br><span class="line">git config --global https.proxy http://127.0.0.1:10809</span><br></pre></td></tr></table></figure></p>
<h4 id="配置ssh">配置SSH</h4>
<p>生成SSH Key： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t ed25519 -C <span class="string">&quot;your_email@example.com&quot;</span></span><br></pre></td></tr></table></figure> 全部默认即可。</p>
<p>然后把Key添加进SSH agent： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">eval</span> <span class="string">&quot;<span class="subst">$(ssh-agent -s)</span>&quot;</span></span><br><span class="line">ssh-add ~/.ssh/id_ed25519</span><br></pre></td></tr></table></figure></p>
<p>获取SSH公钥： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> ~/.ssh/id_ed25519.pub</span><br></pre></td></tr></table></figure> 然后把内容粘贴进github即可。</p>
<h3 id="配置paru">配置paru</h3>
<p><a href="https://github.com/Morganamilo/paru">paru</a>是一款方便的包管理工具。 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://aur.archlinux.org/paru-bin.git</span><br><span class="line"><span class="built_in">cd</span> paru</span><br><span class="line">makepkg -si</span><br></pre></td></tr></table></figure></p>
<p>更改配置文件使其支持代码高亮： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vim /etc/pacman.conf</span><br></pre></td></tr></table></figure></p>
<p>去掉Color行的注释。</p>
<p>更改配置更改排序方式： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vim /etc/paru.conf</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><code>paru -Qtdq</code>查看孤儿包。</p>
</blockquote>
<p>去掉<code>BottomUp</code>行的注释。</p>
<h3 id="配置rust">配置Rust</h3>
<h4 id="配置rustup">配置rustup</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pacman -S rustup</span><br></pre></td></tr></table></figure>
<p>然后通过如下命令配置rustup国内镜像源： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim ~/.bash_profile</span><br></pre></td></tr></table></figure></p>
<p>然后添加如下两行： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> RUSTUP_UPDATE_ROOT=https://mirrors.ustc.edu.cn/rust-static/rustup</span><br><span class="line"><span class="built_in">export</span> RUSTUP_DIST_SERVER=https://mirrors.ustc.edu.cn/rust-static</span><br></pre></td></tr></table></figure></p>
<h4 id="下载rust">下载Rust</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rustup default stable</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用<code>rustup install stable</code>不会从设置好的国内镜像下载，而是从国外下载，速度很慢</p>
</blockquote>
<h4 id="配置cargo镜像源">配置cargo镜像源</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim ~/.cargo/config</span><br></pre></td></tr></table></figure>
<p>并添加如下内容： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[source.crates-io]</span><br><span class="line">registry = <span class="string">&quot;https://github.com/rust-lang/crates.io-index&quot;</span></span><br><span class="line">replace-with = <span class="string">&#x27;sjtu&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 上海交通大学</span></span><br><span class="line">[source.sjtu]</span><br><span class="line">registry = <span class="string">&quot;https://mirrors.sjtug.sjtu.edu.cn/git/crates.io-index/&quot;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="v2raya">v2rayA</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">paru v2raya-bin v2ray</span><br></pre></td></tr></table></figure>
<p>同时开机启动： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> --now v2raya</span><br></pre></td></tr></table></figure></p>
<p>然后从浏览器进入<code>http://localhost:2017</code>，创建一个帐号。</p>
<blockquote>
<p>忘记密码使用<code>sudo v2raya --reset-password</code>命令重置。</p>
</blockquote>
<p>进行如下设置： - 透明代理：大陆白名单 - 透明代理方式：redirect - 规则端口分流模式：大陆白名单 - 防止DNS污染：仅防止DNS劫持（快速） - 特殊模式：supervisor - TCPFastOpen：保持系统默认</p>
<p>其余选项均默认即可。</p>
<blockquote>
<p>注意，若选择GFWList，则需要下载对应的规则库，点击右上角的更新来下载。</p>
</blockquote>
<h3 id="配置neofetch">配置Neofetch</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">paru neofetch</span><br></pre></td></tr></table></figure>
<h3 id="配置terminal">配置Terminal</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">paru zsh</span><br><span class="line">zsh</span><br></pre></td></tr></table></figure>
<p>然后输入0。 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sh -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure></p>
<p>选择把shell切换为zsh，在这里需要重启系统。</p>
<h4 id="安装插件">安装插件</h4>
<h5 id="自动补齐">自动补齐</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-autosuggestions <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-autosuggestions</span><br></pre></td></tr></table></figure>
<p>然后编辑配置文件： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim ~/.zshrc</span><br></pre></td></tr></table></figure></p>
<p>添加相应内容： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">plugins=(other plugins... zsh-autosuggestions)</span><br></pre></td></tr></table></figure></p>
<p>不同插件之间使用空格分割。</p>
<h5 id="代码高亮">代码高亮</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/zsh-users/zsh-syntax-highlighting.git <span class="variable">$&#123;ZSH_CUSTOM:-~/.oh-my-zsh/custom&#125;</span>/plugins/zsh-syntax-highlighting</span><br></pre></td></tr></table></figure>
<p>继续编辑配置文件： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">plugins=( [plugins...] zsh-syntax-highlighting)</span><br></pre></td></tr></table></figure></p>
<h5 id="powerlevel-10k">Powerlevel 10K</h5>
<p>安装对应字体： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">paru ttf powerlevel10k</span><br></pre></td></tr></table></figure></p>
<p>然后安装： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> --depth=1 https://github.com/romkatv/powerlevel10k.git <span class="variable">$&#123;ZSH_CUSTOM:-<span class="variable">$HOME</span>/.oh-my-zsh/custom&#125;</span>/themes/powerlevel10k</span><br></pre></td></tr></table></figure></p>
<p>编辑配置文件，更改主题： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ZSH_THEME=<span class="string">&quot;powerlevel10k/powerlevel10k&quot;</span></span><br></pre></td></tr></table></figure></p>
<p>然后重启terminal进行自动配置。</p>
<blockquote>
<p>输入<code>p10k configure</code>可以重新进行设置</p>
</blockquote>
<h4 id="wezterm主题">Wezterm主题</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/catppuccin/wezterm.git</span><br><span class="line"><span class="built_in">mkdir</span> -p ~/.config/wezterm/colors</span><br><span class="line"><span class="built_in">cp</span> ./wezterm/Catppuccin.toml ~/.config/wezterm/colors/</span><br></pre></td></tr></table></figure>
<h3 id="中文输入支持">中文输入支持</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">paru fcitx5-im</span><br><span class="line">paru fcitx5 chinese addon</span><br></pre></td></tr></table></figure>
<p>安装所有与im相关的community包，然后在设置中搜索<code>input method</code>添加<code>pinyin</code>。</p>
<h4 id="设置环境变量">设置环境变量</h4>
<p>欲在程序中正常启用 Fcitx5, 需设置以下环境变量，并重新登录： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> vim /etc/environment</span><br><span class="line">GTK_IM_MODULE=fcitx</span><br><span class="line">QT_IM_MODULE=fcitx</span><br><span class="line">XMODIFIERS=@im=fcitx</span><br><span class="line">INPUT_METHOD=fcitx</span><br><span class="line">SDL_IM_MODULE=fcitx</span><br><span class="line">GLFW_IM_MODULE=ibus</span><br></pre></td></tr></table></figure></p>
<h3 id="聊天软件">聊天软件</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">paru tim qq</span><br><span class="line">paru wechat desktop</span><br><span class="line">paru telegram</span><br></pre></td></tr></table></figure>
<h3 id="配置vscode">配置vscode</h3>
<p>使得vscode的全局菜单起作用: <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">paru libdbusmenu-glib</span><br></pre></td></tr></table></figure></p>
<p>支持vscode的keyring： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">paru gnome keyring</span><br></pre></td></tr></table></figure></p>
<p>为vscode设置clangd： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">paru clang</span><br></pre></td></tr></table></figure></p>
<p>然后在设置中设置clangd的地址： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">whereis clangd</span><br></pre></td></tr></table></figure></p>
<h3 id="配置chrome">配置Chrome</h3>
<p>启用视频播放硬件加速： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p ~/.config</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;--disable-features=UseChromeOSDirectVideoDecoder --enable-features=VaapiVideoDecoder --ignore-gpu-blocklist --use-gl=desktop&quot;</span> &gt; ~/.config/chrome-flags.conf</span><br></pre></td></tr></table></figure></p>
<h2 id="配置部分驱动">配置部分驱动</h2>
<h3 id="vulkan支持">Vulkan支持</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">paru mesa vulkan</span><br><span class="line"><span class="built_in">sudo</span> sysctl dev.i915.perf_stream_paranoid=0</span><br></pre></td></tr></table></figure>
<h3 id="ntfs支持">NTFS支持</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">paru ntfsprogs-ntfs3</span><br></pre></td></tr></table></figure>
<h3 id="触控板多手势支持">触控板多手势支持</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> pacman -S touchegg</span><br><span class="line">paru touche</span><br><span class="line"><span class="built_in">sudo</span> systemctl <span class="built_in">enable</span> touchegg.services</span><br></pre></td></tr></table></figure>
<h3 id="指纹识别支持">指纹识别支持</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">paru fprint</span><br></pre></td></tr></table></figure>
<h2 id="系统主题配置">系统主题配置</h2>
<p>首先需要下载一些依赖： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">paru kvantum</span><br></pre></td></tr></table></figure></p>
<h3 id="配置dock">配置dock</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">paru latte dock</span><br></pre></td></tr></table></figure>
<p>然后启动<code>latte dock</code>。</p>
<h4 id="高级模式">高级模式</h4>
<p>右键dock点击编辑，然后开启高级模式：</p>
<p>Apperance:</p>
<ul>
<li>background:
<ul>
<li>height: 100%</li>
<li>opacity: 30%</li>
<li>check: blur</li>
<li>radius: 15%</li>
</ul></li>
<li>margins
<ul>
<li>screen edge: 4px</li>
</ul></li>
</ul>
<p>点击编辑面板左下角的Add panel，点击添加空白panel。</p>
<h3 id="配置上边栏">配置上边栏</h3>
<p>右键上边栏，选择编辑：</p>
<p>Apperance:</p>
<ul>
<li>items
<ul>
<li>absolute size: 30px</li>
</ul></li>
<li>length
<ul>
<li>maximum: 99%</li>
</ul></li>
<li>margins
<ul>
<li>screen edge: 3px</li>
</ul></li>
<li>background
<ul>
<li>opacity: 30%</li>
<li>check: blur</li>
<li>radius: 50%</li>
<li>check: prefre opac background when window touching</li>
</ul></li>
</ul>
<p>Behavior:</p>
<ul>
<li>actions
<ul>
<li>check: hide floating gap when maxmaized window</li>
</ul></li>
</ul>
<h4 id="配置widgets">配置Widgets</h4>
<p>首先下载一些控件：</p>
<ul>
<li>better inline clock</li>
<li>application name mac style</li>
</ul>
<p>右键桌面空白区域，点击添加Widgets：</p>
<ul>
<li>搜索system tray，添加到上边栏最右侧</li>
<li>搜索application menu，添加到最左侧</li>
<li>搜索bertter inline clock，添加到中间</li>
<li>搜索application title，添加到application menu右侧</li>
<li>搜索global menu，添加到application title右侧</li>
</ul>
<p>编辑application title，编辑no active window label为custom text，并添加文本内容。</p>
<h3 id="配置krunner">配置KRunner</h3>
<p>点击编辑，使其居中，取消勾选记住上次搜索。</p>
<h3 id="系统设置">系统设置</h3>
<p>首先把<code>clicking files or folders</code>改成<code>selects them</code>。<br />
打开<code>workspace behavior</code>中<code>desktop effect</code>里的<code>blur</code>、<code>magic lamp</code>、<code>slide back</code>、<code>overview</code>，并为overview设置快捷键，用touche配置相应的手势操作。</p>
<h4 id="global-theme">Global theme</h4>
<p>下载layan，并启用。</p>
<h5 id="application-style">Application style</h5>
<p>下载layan gtk theme，并启用。</p>
<h5 id="window-decoration">Window decoration</h5>
<p>编辑关闭、最大化、最小化按键位置。</p>
<h5 id="icons">Icons</h5>
<p>下载Mac mod flat icon，并启用Papirus。</p>
<h3 id="配置kvantum">配置Kvantum</h3>
<p>从<a href="https://store.kde.org/p/1325246/">这里</a>下载相应的文件，然后启动Kvantum manager，安装并使用该主题，编辑该主题，取消勾选<code>Disable translucency when non-integer scaling</code>，否则部分内容不会blur。</p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title>安装Arch Linux</title>
    <url>/2022/03/15/archlinux/</url>
    <content><![CDATA[<p>需要从<a href="https://archlinux.org/download/">官网下载系统镜像</a>，制作USB安装介质，使用UEFI启动后再进行下一步行动。</p>
<blockquote>
<p>注意：USB盘符应为<code>ARCH_202203</code>之类的，否则会无法进入安装介质。</p>
</blockquote>
<span id="more"></span>
<h2 id="windows-dual-boot">Windows Dual Boot</h2>
<ol type="1">
<li>为Opencore分好区，并把文件放入</li>
<li>把装有Windows安装介质的U盘插入电脑，并从Opencore启动安装</li>
<li>正常安装即可</li>
</ol>
<h2 id="安装介质中的准备操作">安装介质中的准备操作</h2>
<h3 id="连接网络">连接网络</h3>
<h4 id="启动应用">启动应用</h4>
<p>输入<code>iwctl</code>来进入网络连接界面，进入后输入<code>help</code>查看具体操作。查看设备地址（默认为<code>wlan0</code>），然后输入<code>station wlan0 connect "WIFI-SSID"</code>或<code>station wlan0 connect-hidden "HIDDEN-WIFI-SSID"</code>来连接相应的WiFi。</p>
<p>输入<code>exit</code>退出<code>iwctl</code>。</p>
<h4 id="测试网络">测试网络</h4>
<p>输入<code>ping -c 5 bing.com</code>来测试网络连接情况。</p>
<h4 id="调试pacman">调试<code>pacman</code></h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">reflector --country China --age 24 --<span class="built_in">sort</span> rate --protocol https --save /etc/pacman.d/mirrorlist</span><br></pre></td></tr></table></figure>
<h3 id="硬盘操作">硬盘操作</h3>
<h4 id="硬盘格式化分区">硬盘格式化/分区</h4>
<p>建议在其他系统下格式化好，<br />
需要如下两个分区：</p>
<ul>
<li>EFI分区，FAT32格式</li>
<li>根目录分区，F2FS格式</li>
</ul>
<h4 id="硬盘分区挂载">硬盘分区挂载</h4>
<p>使用<code>lsblk</code>来查看硬盘分区及挂载情况。</p>
<p>挂载根目录分区： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount /dev/YOUR-ROOT-PARTITION /mnt</span><br></pre></td></tr></table></figure></p>
<p>新建文件夹用于挂载EFI： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -p /mnt/boot</span><br></pre></td></tr></table></figure></p>
<p>挂载EFI分区： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mount /dev/YOUR-EFI-PARTITION /mnt/boot</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>挂载顺序一定要先挂载<code>root</code>，再挂载<code>boot</code>！</p>
</blockquote>
<h3 id="开始安装系统">开始安装系统</h3>
<p>安装基本功能，后续系统安装进入系统操作。<br />
输入如下命令来安装基本功能：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pacstrap /mnt base linux linux-firmware</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以选择安装<code>linux-lts</code>，或者同时安装两种核心。</p>
</blockquote>
<h4 id="写入文件表">写入文件表</h4>
<p>运行 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">genfstab -U /mnt &gt;&gt; /mnt/etc/fstab</span><br></pre></td></tr></table></figure></p>
<h2 id="系统核心安装">系统核心安装</h2>
<p>首先输入<code>arch-chroot /mnt</code>来进入新系统。</p>
<h3 id="安装linux核心">安装Linux核心</h3>
<p>首先安装部分工具来方便执行命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pacman -S bash-completion vim</span><br></pre></td></tr></table></figure>
<h4 id="语言配置">语言配置</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/locale.conf</span><br></pre></td></tr></table></figure>
<p>然后在第一行输入<code>LANG=en_US.UTF-8</code>。</p>
<p>进入<code>locale.gen</code>编辑：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/locale.gen</span><br></pre></td></tr></table></figure>
<p>去掉<code>en_US.UTF-8</code>和<code>zh_CN.UFT-8</code>前的注释，然后通过如下命令使其生效： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">locale-gen</span><br></pre></td></tr></table></figure></p>
<h4 id="安装开发工具">安装开发工具</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pacman -S linux-headers base-devel</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>base-devel</code>包含<code>gcc</code>等工具。</p>
</blockquote>
<h3 id="网络安装及设置">网络安装及设置</h3>
<h4 id="网络控制安装">网络控制安装</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pacman -S networkmanager</span><br></pre></td></tr></table></figure>
<h4 id="网络配置">网络配置</h4>
<p>设置开机自动启动：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> NetworkManager</span><br></pre></td></tr></table></figure>
<h3 id="硬盘管理安装">硬盘管理安装</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pacman -S lvm2</span><br></pre></td></tr></table></figure>
<p>并通过如下命令编辑<code>HOOKS</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/mkinitcpio.conf</span><br></pre></td></tr></table></figure>
<p>找到<code>HOOKS=</code>那一行，在<code>block</code>和<code>filesystems</code>之间加入<code>lvm2</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">HOOKS=(... block lvm2 filesystems ...)</span><br></pre></td></tr></table></figure>
<p>通过如下命令让其生效：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkinitcpio -p linux</span><br></pre></td></tr></table></figure>
<blockquote>
<p>如果安装了<code>linux-lts</code>需要继续执行<code>mkinitcpio -p linux-lts</code></p>
</blockquote>
<h3 id="用户设置">用户设置</h3>
<p>首先通过如下命令对<code>root</code>用户设置密码： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">passwd</span><br></pre></td></tr></table></figure></p>
<h4 id="添加一般用户">添加一般用户</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">useradd -m -g <span class="built_in">users</span> -G wheel YOUR_USER_NAME</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>-m</code>将会生成用户目录<br />
<code>-g users</code>把用户加入该组，<code>-G wheel</code>使该用户可以使用<code>sudo</code>来提权</p>
</blockquote>
<p>然后使用如下命令来为该用户设置密码： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">passwd YOUR_USER_NAME</span><br></pre></td></tr></table></figure></p>
<h5 id="为一般用户配置sudo">为一般用户配置<code>sudo</code></h5>
<p>首先确定<code>sudo</code>已经安装： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pacman -S <span class="built_in">sudo</span></span><br></pre></td></tr></table></figure></p>
<p>然后编辑设置文件： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">EDITOR=vim visudo</span><br></pre></td></tr></table></figure></p>
<p>去掉下面这行的注释： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">%wheel ALL=(ALL) ALL</span><br></pre></td></tr></table></figure></p>
<h3 id="安装grub">安装GRUB</h3>
<p>首先安装对应的组件： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pacman -S intel-ucode grub efibootmgr mtools</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>AMD处理器请安装<code>amd-ucode</code></p>
</blockquote>
<p>然后进行安装： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grub-install --target=x86_64-efi --efi-directory=/boot --bootloader-id=grub_uefi --recheck</span><br></pre></td></tr></table></figure></p>
<p>编辑配置文件，让grub默认直接进入Linux： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/default/grub</span><br></pre></td></tr></table></figure></p>
<p>修改如下内容： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">RUB_CMDLINE_LINUX_DEFAULT=<span class="string">&quot;&quot;</span></span><br><span class="line">GRUB_TIMEOUT=0</span><br><span class="line">GRUB_TIMEOUT_STYLE=hidden</span><br><span class="line">GRUB_HIDDEN_TIMEOUT=0</span><br><span class="line">GRUB_HIDDEN_TIMEOUT_QUIET=<span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<p>生成配置文件：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">grub-mkconfig -o /boot/grub/grub.cfg</span><br></pre></td></tr></table></figure>
<blockquote>
<p>grub不会覆盖opencore</p>
</blockquote>
<h3 id="拔出u盘前的准备">拔出U盘前的准备</h3>
<p>输入<code>exit</code>退出到安装介质的系统，然后输入如下命令卸载所有挂载硬盘： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">umount -a</span><br></pre></td></tr></table></figure></p>
<p>然后输入<code>reboot</code>就可以拔出U盘，直接进入安装的系统。</p>
<h2 id="配置新系统">配置新系统</h2>
<p>进入新系统后，要求输入用户名，输入<code>root</code>及密码，以便以<code>root</code>权限进行相应配置。</p>
<h3 id="联网">联网</h3>
<p>首先查看设备地址： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ip addr list</span><br></pre></td></tr></table></figure></p>
<p>一般第二项是WiFi设备地址，如<code>wlp2s0</code>，且此时没有联网，无IP地址。</p>
<p>然后输入如下命令进入网络管理界面： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmtui</span><br></pre></td></tr></table></figure></p>
<p>然后选择<code>Add</code>，添加要链接的网络的信息，设备输入上面获得的WiFi地址。</p>
<p>添加后退出，然后输入<code>nmcli con up &lt;connection name&gt;</code>来链接网络。</p>
<h3 id="配置中英字体">配置中英字体</h3>
<h4 id="下载字体">下载字体</h4>
<p>部分英文字体： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pacman -S ttf-dejavu ttf-font-awesome otf-font-awesome ttf-lato ttf-liberation ttf-linux-libertine ttf-opensans ttf-roboto ttf-hack</span><br></pre></td></tr></table></figure></p>
<p>部分中文字体： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pacman -S noto-fonts noto-fonts-extra noto-fonts-emoji adobe-source-han-sans-cn-fonts adobe-source-han-sans-hk-fonts wqy-microhei</span><br></pre></td></tr></table></figure></p>
<h3 id="配置内存换页">配置内存换页</h3>
<blockquote>
<p>brtfs类型的文件系统无法配置</p>
</blockquote>
<p>这里展示配置512MB的换页内存： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">dd</span> <span class="keyword">if</span>=/dev/zero of=/swapfile bs=1M count=512 status=progress</span><br></pre></td></tr></table></figure></p>
<p>配置权限： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 600 /swapfile</span><br></pre></td></tr></table></figure></p>
<p>通过如下命令让系统得知该换页： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkswap /swapfile</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;/swapfile none swap sw 0 0&#x27;</span> | <span class="built_in">tee</span> -a /etc/fstab</span><br></pre></td></tr></table></figure></p>
<p>启动内存换页： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">swapon -a</span><br></pre></td></tr></table></figure></p>
<h3 id="配置时间及时区">配置时间及时区</h3>
<p>设置时区： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">timedatectl set-timezone Asia/Shanghai</span><br></pre></td></tr></table></figure></p>
<p>设置时间同步： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> systemd-timesyncd</span><br></pre></td></tr></table></figure></p>
<h3 id="设置主机名">设置主机名</h3>
<p>以<code>xiaobaiArch</code>为例： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hostnamectl set-hostname xiaobaiArch</span><br></pre></td></tr></table></figure></p>
<h4 id="配置hosts文件">配置<code>hosts</code>文件</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/hosts</span><br></pre></td></tr></table></figure>
<p>并添加如下两行： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">127.0.0.1   localhost</span><br><span class="line">127.0.1.1   xiaobaiArch</span><br></pre></td></tr></table></figure> &gt; 这里的名称要与主机名相同</p>
<h3 id="配置部分硬件">配置部分硬件</h3>
<h4 id="显卡驱动">显卡驱动</h4>
<h5 id="intel核显">Intel核显</h5>
<p>对于Intel： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pacman -S mesa xf86-video-intel intel-media-driver</span><br></pre></td></tr></table></figure></p>
<h5 id="amd显卡">AMD显卡</h5>
<p>对于AMD： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pacman -S mesa xf86-video-amdgpu vulkan-radeon libva-mesa-driver mesa-vdpau</span><br></pre></td></tr></table></figure></p>
<h4 id="声卡驱动">声卡驱动</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pacman -S alsa-utils pulseaudio pulseaudio-bluetooth cups</span><br></pre></td></tr></table></figure>
<h4 id="蓝牙驱动">蓝牙驱动</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pacman -S bluez bluez-utils</span><br><span class="line">systemctl <span class="built_in">enable</span> bluetooth</span><br></pre></td></tr></table></figure>
<h3 id="配置图形化界面">配置图形化界面</h3>
<h4 id="安装xorg服务">安装<code>xorg</code>服务</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pacman -S xorg-server</span><br></pre></td></tr></table></figure>
<h5 id="开启truetype渲染">开启<code>truetype</code>渲染</h5>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/profile.d/freetype2.sh</span><br></pre></td></tr></table></figure>
<p>然后把最后一行去注释。</p>
<h4 id="安装kde">安装KDE</h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">pacman -S plasma-meta plasma-desktop sddm kscreen plasma-pa ffmpegthumbs dolphin konsole ark vlc</span><br></pre></td></tr></table></figure>
<p>启动登陆图形化界面 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> sddm</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>完成！</p>
</blockquote>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title>再见，兔崽子</title>
    <url>/2024/03/13/byte-little-rabbit/</url>
    <content><![CDATA[<p>Bye.</p>
<span id="more"></span>
<p>对不起我没有照顾好你，想家了就回家看看。</p>
]]></content>
      <categories>
        <category>Life is strange</category>
      </categories>
      <tags>
        <tag>Life</tag>
      </tags>
  </entry>
  <entry>
    <title>CS自学教程</title>
    <url>/2022/03/26/cs-self-learn/</url>
    <content><![CDATA[<h2 id="编程入门">编程入门</h2>
<h3 id="cs106l">CS106L</h3>
<p>Standard C++ Programming，这门课会深入到很多标准C++的特性和语法，让你编写出高质量的C++代码。例如auto binding，uniform initialization，lambda function，move semantics，RAII等技巧。</p>
<span id="more"></span>
<p>值得一提的是，这门课的作业里你会实现一个HashMap（类似于STL中的unordered map), 这个作业几乎把整个课程串联了起来，非常考验代码能力。</p>
<h4 id="课程资源">课程资源</h4>
<ul>
<li>课程网站
<ul>
<li><a href="http://web.stanford.edu/class/cs106l/">CS106L</a></li>
</ul></li>
<li>参考教材
<ul>
<li><a href="http://web.stanford.edu/class/cs106l/full_course_reader.pdf">Reader</a></li>
</ul></li>
<li>课程视频
<ul>
<li><a href="https://www.youtube.com/channel/UCSqr6y-eaQT_qZJVUm_4QxQ/playlists">Youtube</a></li>
</ul></li>
</ul>
<h2 id="电子基础">电子基础</h2>
<h3 id="ucb-ee16ab">UCB EE16A&amp;B</h3>
<p>Designing Information Devices and Systems I&amp;II，电子基础知识的讲授，用Python进行编程。</p>
<h4 id="课程资源-1">课程资源</h4>
<ul>
<li>课程网站
<ul>
<li><a href="https://inst.eecs.berkeley.edu/~ee16a/su20/#schedule">EE16A</a></li>
<li><a href="https://www.eecs16b.org/#schedule">EE16B</a></li>
</ul></li>
<li>课程视频
<ul>
<li><a href="https://www.bilibili.com/video/BV1uK4y1M7cJ">Bilibili</a></li>
</ul></li>
</ul>
<h3 id="ucb-ee120">UCB EE120</h3>
<p>Signal and Systems，这门课最精华的部分就是6个超有趣的编程作业了，会让你用Python通过学习到的信号与系统的理论知识，解决各类实际问题。例如lab3会让你实现FFT算法，并和Numpy的官方实现进行性能对比；lab4会通过分析手指头的影像数据推断心率；lab5就更牛了，会让你给哈勃望远镜拍到的照片进行降噪处理，恢复绚烂清晰的星空；lab6会让你构造一个反馈系统，平衡小车上的细杆。</p>
<h4 id="课程资源-2">课程资源</h4>
<ul>
<li>课程网站
<ul>
<li><a href="https://inst.eecs.berkeley.edu/~ee120/fa19/">EE120</a></li>
</ul></li>
<li>课程视频
<ul>
<li><a href="https://www.bilibili.com/video/BV1k341187vL">Bilibili</a></li>
</ul></li>
</ul>
<h2 id="数据结构和算法">数据结构和算法</h2>
<h3 id="cs61b">CS61B</h3>
<p>Data Structures and Algorithms，伯克利CS61系列的第二门课程，注重数据结构与算法的设计，同时让学生有机会接触上千行的工程代码，通过Java初步领会软件工程的思想。14个lab会让你自己实现课上所讲的绝大部分数据结构，10个homework会让你运用数据结构和算法解决实际问题， 另外还有3个Project更是让你有机会接触上千行的工程代码，在实战中磨练自己的Java能力。</p>
<h4 id="课程资源-3">课程资源</h4>
<ul>
<li>课程网站
<ul>
<li><a href="https://sp21.datastructur.es/">CS16B</a></li>
</ul></li>
<li>课程视频
<ul>
<li><a href="https://sp21.datastructur.es/">课程主页</a></li>
</ul></li>
</ul>
<h3 id="coursera">Coursera</h3>
<p>Algorithms I &amp; II，让你完全掌握一个算法的核心在于理解三点：</p>
<ul>
<li>为什么这么做？（正确性推导，抑或是整个算法的核心本质）</li>
<li>如何实现它？（光学不用假把式）</li>
<li>用它解决实际问题（学以致用才是真本事）</li>
</ul>
<p>这门课的构成就非常好地契合了上述三个步骤。观看课程视频并且阅读教授的开源课本有助于你理解算法的本质，让你也可以用非常 生动浅显的话语向别人讲述为什么这个算法得长这个样子。</p>
<p>在理解算法之后，你可以阅读教授对于课程中讲授的所有数据结构与算法的代码实现。 注意，这些实现可不是demo性质的，而是工业级的高效实现，从注释到变量命名都非常严谨，模块化也做得相当好，是质量很高的代码。我从这些代码中收获良多。</p>
<p>最后，就是这门课最激动人心的部分了，10个高质量的Project，并且全都有实际问题的背景描述，丰富的测试样例，自动的评分系统（代码风格也是评分的一环）。让你在实际生活中 领略算法的魅力。</p>
<h4 id="课程资源-4">课程资源</h4>
<ul>
<li>课程网站
<ul>
<li><a href="https://www.coursera.org/learn/algorithms-part1">Algorithms I</a></li>
<li><a href="https://www.coursera.org/learn/algorithms-part2">Algorithms I</a></li>
</ul></li>
<li>参考教材
<ul>
<li><a href="https://algs4.cs.princeton.edu/home/">开源教材</a></li>
</ul></li>
</ul>
<h2 id="软件工程">软件工程</h2>
<h3 id="mit-6.031">MIT 6.031</h3>
<p>Software Construction，这门课的目标就是让学生学会如何写出高质量的代码，所谓高质量，则是满足下面三个目标（课程设计者原话复制，以防自己翻译曲解本意）：</p>
<ul>
<li>Safe from bugs. Correctness (correct behavior right now) and defensiveness (correct behavior in the future) are required in any software we build.</li>
<li>Easy to understand. The code has to communicate to future programmers who need to understand it and make changes in it (fixing bugs or adding new features). That future programmer might be you, months or years from now. You’ll be surprised how much you forget if you don’t write it down, and how much it helps your own future self to have a good design.</li>
<li>Ready for change. Software always changes. Some designs make it easy to make changes; others require throwing away and rewriting a lot of code.</li>
</ul>
<p>为此，这门课的设计者们精心编写了一本书来阐释诸多软件构建的核心原则与前人总结下来的宝贵经验，内容细节到如何编写注释和函数Specification，如何设计抽象数据结构以及诸多并行编程的内容，并且会让你在精心设计的Java编程项目里体验和练习这些编程模式。</p>
<p>2016年春季学期这门课开源了其所有编程作业的代码框架，而最新的课程教材可以在其最新的教学网站上找到，具体链接参见下方。</p>
<h4 id="课程资源-5">课程资源</h4>
<ul>
<li>课程网站
<ul>
<li><a href="http://web.mit.edu/6.031/www/sp21/">2021</a></li>
<li><a href="https://ocw.mit.edu/courses/electrical-engineering-and-computer-science/6-005-software-construction-spring-2016/">2016</a></li>
</ul></li>
</ul>
<h2 id="体系结构">体系结构</h2>
<h3 id="coursera-nand2tetris">Coursera: Nand2Tetris</h3>
<p>让一个完全没有计算机基础的人从与非门开始 造一台计算机，并在上面运行俄罗斯方块小游戏。</p>
<p>听起来就很酷对不对？实现起来更酷！这门课分为硬件和软件两个部分。在硬件部分，你将进入01的世界，用与非门构造出逻辑电路，并逐步搭建出一个CPU 来运行一套课程作者定义的简易汇编代码。在软件部分，你将编写一个编译器，将作者开发的一个名为Jack的高级语言编译为可以运行在虚拟机上的字节码，然后进一步翻译 为汇编代码。你还将开发一个简易的OS，让你的计算机支持输入输出图形界面。至此，你可以用Jack开发一个俄罗斯方块的小游戏，将它 编译为汇编代码，运行在你用与非门搭建出的CPU上，通过你开发的OS进行交互。学完这门课程，你将对整个计算机的体系结构有一个全局 且深刻的理解，对于你后续课程的学习有着莫大的帮助。</p>
<p>你也许会担心课程会不会很难，但这门课面向的人群是完全没有计算机基础的人，课程作者的目标是让高中生都能理解。因此，只要你按部就班跟着 课程规划走，一个月内学完应该绰绰有余。麻雀虽小但是五脏俱全，这门课很好地提取出了计算机的本质，而不过多地陷于现代计算机为了性能而 设计出的众多复杂细节。让学习者能在轻松愉快的学习体验中感受计算机的优雅与神奇。</p>
<h4 id="课程资源-6">课程资源</h4>
<ul>
<li>课程网站
<ul>
<li><a href="https://www.coursera.org/learn/build-a-computer">Part 1</a></li>
<li><a href="https://www.coursera.org/learn/nand2tetris2">Part 2</a></li>
</ul></li>
<li>参考教材
<ul>
<li><a href="https://github.com/PKUFlyingPig/NandToTetris/blob/master/%5B%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E8%A6%81%E7%B4%A0%EF%BC%9A%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E6%9E%84%E5%BB%BA%E7%8E%B0%E4%BB%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%5D.(%E5%B0%BC%E8%90%A8).%E5%91%A8%E7%BB%B4.%E6%89%AB%E6%8F%8F%E7%89%88.pdf">Github</a></li>
</ul></li>
</ul>
<h3 id="cs61c-great-ideas-in-computer-architecture">CS61C: Great Ideas in Computer Architecture</h3>
<p>伯克利CS61系列的最后一门课程，深入计算机的硬件细节，带领学生逐步理解C语言是如何一步步转化为RISC-V汇编并在CPU上执行的。和Nand2Tetris不同，这门课在难度和深度上都会大很多，具体会涉及到流水线、Cache、虚存以及并发相关的内容。</p>
<p>这门课的Project也非常新颖有趣。Project1会让你用C语言写一个小程序，20年秋季学期是著名的游戏Game of Life。Project2会让你用RISC-V汇编编写一个神经网络，用来 识别MNIST手写数字，非常锻炼你对汇编代码的理解和运用。Project3中你会用Logisim这个数字电路模拟软件搭建出一个二级流水线的CPU，并在上面运行RISC-V汇编代码。Project4 会让你使用OpenMP，SIMD等方法并行优化矩阵运算，实现一个简易的Numpy。</p>
<h4 id="课程资源-7">课程资源</h4>
<ul>
<li>课程网站
<ul>
<li><a href="https://inst.eecs.berkeley.edu/~cs61c/su20/">CS61C</a></li>
</ul></li>
<li>课程视频
<ul>
<li><a href="https://www.bilibili.com/video/BV1fC4y147iZ?from=search&amp;seid=1039011700066128636">Bilibili</a></li>
<li><a href="https://www.youtube.com/playlist?list=PLDoI-XvXO0aqgoMQvogzmf7CKiSMSUS3M">Youtube</a></li>
</ul></li>
</ul>
<h3 id="csapp">CSAPP</h3>
<p>CMU大名鼎鼎的镇系神课，以其内容庞杂，project巨难而闻名遐迩。课程内容覆盖了汇编语言、体系结构、操作系统、编译链接、并行、网络等，作为系统入门课，兼具深度和广度，如果自学确实需要相当的毅力和代码功底。</p>
<p>这门课配合的教材由CMU计算机系主任Bryant教授执笔，也即所谓的CSAPP。这也是我第一本认认真真一页一页读过去的计算机教材，虽然很难啃，但着实收获良多。</p>
<p>北大购买了这门课的版权并开设了Introduction to Computer System这门课，但其实CSAPP所有的课程资源和实验代码都能在它的官方主页上访问到（具体参见下方链接）。</p>
<p>这门课由于过于出名，全世界的码农争相学习，导致其Project的答案在网上几乎唾手可得。但如果你真的想锻炼自己的代码能力，希望你不要借鉴任何第三方代码。</p>
<p>认真学完这一门课，你对计算机系统的理解绝对会上升一个台阶。</p>
<blockquote>
<p>相信大家在看完CSAPP这本书以后，可能会对书中的第七章链接有一定的疑问。这里推荐一本书《程序员的自我修养》，书的副标题是链接，装载与库。这本书能够帮助我们完善对程序链接的理解，以及对CSAPP第七章部分知识点的一个详细的阐述。相信你在看完这本书以后可以对程序的链接，ELF文件，动态库有一个更加深入的理解。十分推荐在读完CSAPP，对计算机系统有一定的了解以后作为补充资料来阅读。</p>
</blockquote>
<h4 id="课程资源-8">课程资源</h4>
<ul>
<li>课程网站
<ul>
<li><a href="http://csapp.cs.cmu.edu/">CSAPP</a></li>
</ul></li>
<li>课程视频
<ul>
<li><a href="https://www.bilibili.com/video/BV1iW411d7hd">Bilibili</a></li>
</ul></li>
<li>课程作业
<ul>
<li><a href="http://csapp.cs.cmu.edu/3e/labs.html">代码框架已开源</a></li>
</ul></li>
</ul>
<h2 id="操作系统">操作系统</h2>
<h3 id="mit-6.s081-operating-system-engineering">MIT 6.S081: Operating System Engineering</h3>
<p>麻省理工学院大名鼎鼎的PDOS实验室开设的面向MIT本科生的操作系统课程。开设这门课的教授之一 —— Robert Morris教授曾是一位顶尖黑客，世界上第一个蠕虫病毒Morris就是出自他之手。</p>
<p>这门课的前身是MIT著名的课程6.828，MIT的几位教授为了这门课曾专门开发了一个基于X86的教学用操作系统JOS，被众多名校作为自己的操统课程实验。但随着RISC-V的横空出世，这几位教授又基于RISC-V开发了一个新的教学用操作系统xv6，并开设了MIT6.S081这门课。由于RISC-V轻便易学的特点，学生不需要像此前JOS一样纠结于众多X86“特有的”为了兼容而遗留下来的复杂机制，而 可以专注于操作系统层面的开发。</p>
<p>这几位教授还专门写了一本<a href="https://pdos.csail.mit.edu/6.828/2021/xv6/book-riscv-rev2.pdf">教程</a>，详细讲解了xv6的设计思想和实现细节。</p>
<p>这门课的讲授也很有意思，老师会带着学生依照xv6的源代码去理解操作系统的众多机制和设计细节，而不是停留于理论知识。每周都会有一个lab，让你在xv6上增加一些新的机制和特性，非常注重学生动手能力的培养。整个学期一共有11个lab，让你全方位地深刻理解操作系统的每个部分，非常有成就感。而且所有的lab都有着非常完善的测试框架，有的测试代码甚至上千行，让人不得不佩服MIT的几位教授为了教好这门课所付出的心血。</p>
<p>这门课的后半程会讲授操作系统领域的多篇经典论文，涉及文件系统、系统安全、网络、虚拟化等等多个主题，让你有机会接触到学界 最前沿的研究方向。</p>
<h4 id="课程资源-9">课程资源</h4>
<ul>
<li>课程网站
<ul>
<li><a href="https://pdos.csail.mit.edu/6.828/2021/xv6/book-riscv-rev2.pdf">OS</a></li>
</ul></li>
<li>课程视频
<ul>
<li><a href="https://www.bilibili.com/video/BV19k4y1C7kA">Bilibili</a></li>
</ul></li>
</ul>
<h3 id="cs162-operating-system">CS162: Operating System</h3>
<p>这门课让我记忆犹新的有两个部分：</p>
<p>首先是教材，这本书用的教材Operating Systems: Principles and Practice (2nd Edition)一共四卷，写得 非常深入浅出，很好地弥补了MIT6.S081在理论知识上些许空白，非常建议大家阅读。相关资源会分享在本书的经典书籍推荐模块。</p>
<p>其次是这门课的Project —— Pintos。Pintos是由Ben Pfaff等人基于X86编写的教学用操作系统，Ben Pfaff甚至专门发了篇 paper来阐述Pintos的设计思想。和MIT的xv6小而精的lab设计理念不同， Pintos更注重系统的Design and Implementation。Pintos本身仅一万行左右，只提供了操作系统最基本的功能。而4个Project，就是让你在这个极为精简的操作系统之上，分别为其增加线程调度机制（Project1），系统调用（Project2），虚拟内存（Project3）以及文件系统（Project4）。所有的Project都给学生留有很大的设计空间，总代码量在5000行以上。根据Stanford学生自己的反馈，在3-4人组队的情况下，后两个Project的人均耗时也在40个小时以上。</p>
<p>虽然其难度很大，但Stanford，Berkeley，JHU等多所美国顶尖名校的操统课程均采用了Pintos。因为如果你真的对操作系统很感兴趣，Pintos会极大地提高你编写和debug底层系统代码的能力。在本科阶段，能自己设计、实现并debug一个大型系统，是一段非常珍贵的经历。</p>
<h4 id="课程资源-10">课程资源</h4>
<ul>
<li>课程网站
<ul>
<li><a href="https://cs162.org/">CS162</a></li>
</ul></li>
<li>课程视频
<ul>
<li><a href="https://www.bilibili.com/video/BV1yk4y1q7C6">Bilibili</a></li>
</ul></li>
<li>课程教材
<ul>
<li><a href="http://ospp.cs.washington.edu/">OSPP</a></li>
</ul></li>
</ul>
<h2 id="计算机网络">计算机网络</h2>
<h3 id="computer-networking-a-top-down-approach">Computer Networking: A Top-Down Approach</h3>
<p>《自顶向下方法》是计算机网络领域的一本经典教材，两位作者Jim Kurose和Keith Ross精心制作了教材配套的课程网站，并且公开了自己录制的网课视频，交互式的在线章节测试，以及利用wireshark进行抓包分析的lab。唯一遗憾的是这门课并没有硬核的编程作业，而Stanford的CS144能很好地弥补这一点。</p>
<h4 id="课程资源-11">课程资源</h4>
<ul>
<li>课程网站
<ul>
<li><a href="https://gaia.cs.umass.edu/kurose_ross/index.php">CNATA</a></li>
</ul></li>
<li>课程视频
<ul>
<li><a href="https://gaia.cs.umass.edu/kurose_ross/lectures.php">Youtube</a></li>
</ul></li>
<li>课程作业
<ul>
<li><a href="https://gaia.cs.umass.edu/kurose_ross/wireshark.php">Assignments</a></li>
</ul></li>
</ul>
<h3 id="cs144-computer-network">CS144: Computer Network</h3>
<p>这门课的主讲人之一是网络领域的巨擘Nick McKeown教授。这位拥有自己创业公司的学界业界双巨佬会在他慕课每一章节的最后采访一位业界的高管或者学界的高人，非常开阔眼界。</p>
<p>在这门课的Project中，你将用C++循序渐进地搭建出整个TCP/IP协议栈，实现IP路由以及ARP协议，最后利用你自己的协议栈代替Linux Kernel的网络协议栈和其他学生的计算机进行通信，非常amazing！</p>
<h4 id="课程资源-12">课程资源</h4>
<ul>
<li>课程网站
<ul>
<li><a href="https://cs144.github.io/">Github</a></li>
</ul></li>
<li>课程视频
<ul>
<li><a href="https://www.youtube.com/watch?v=r2WZNaFyrbQ&amp;list=PL6RdenZrxrw9inR-IJv-erlOKRHjymxMN">Youtube</a></li>
</ul></li>
<li>课程作业
<ul>
<li><a href="https://cs144.github.io/">Github</a></li>
</ul></li>
</ul>
<h2 id="编译原理">编译原理</h2>
<h3 id="stanford-cs143-compilers">Stanford CS143: Compilers</h3>
<p>斯坦福的编译原理课程，设计者开发了一个Class-Object-Oriented-Language，简称COOL语言。这门课的核心就是通过理论知识的学习，为COOL语言实现一个编译器，将COOL高级语言编译为MIPS汇编并在Spim这个MIPS模拟器上成功执行。</p>
<p>理论部分基本按照龙书的顺序覆盖了词法分析、语法分析、语义分析、运行时环境、寄存器分配、代码优化与生成等内容，实践部分则相应地分为词法分析、语法分析、语义分析、代码生成四个阶段，难度循序渐进，并在优化部分给学生留下了很大的设计空间。</p>
<h4 id="课程资源-13">课程资源</h4>
<ul>
<li>课程网站
<ul>
<li><a href="http://web.stanford.edu/class/cs143/">CS143</a></li>
</ul></li>
<li>课程视频
<ul>
<li><a href="https://www.bilibili.com/video/BV17K4y147Bz">Bilibili</a></li>
</ul></li>
</ul>
<h2 id="计算机图形学">计算机图形学</h2>
<h3 id="games101">GAMES101</h3>
<p>大名鼎鼎无需多言。</p>
<h2 id="人工智能">人工智能</h2>
<h3 id="cs188-introduction-to-artificial-intelligence">CS188: Introduction to Artificial Intelligence</h3>
<p>伯克利的人工智能入门课，课程notes写得非常深入浅出，基本不需要观看课程视频。课程内容的安排基本按照人工智能的经典教材Artificial intelligence: A Modern Approach的章节顺序，覆盖了搜索剪枝、约束满足问题、马尔可夫决策过程、强化学习、贝叶斯网络、隐马尔可夫模型以及基础的机器学习和神经网络的相关内容。</p>
<p>2018年秋季学期的版本免费开放了gradescope，大家可以在线完成书面作业并实时得到测评结果。同时课程的6个Project也是质量爆炸，复现了经典的Packman（吃豆人）小游戏，会让你利用学到的AI知识，去实现相关算法，让你的吃豆人在迷宫里自由穿梭，躲避鬼怪，收集豆子。</p>
<h4 id="课程资源-14">课程资源</h4>
<ul>
<li>课程网站
<ul>
<li><a href="https://inst.eecs.berkeley.edu/~cs188/fa18/index.html">CS188</a></li>
</ul></li>
<li>课程视频
<ul>
<li><a href="https://inst.eecs.berkeley.edu/~cs188/fa18/index.html">Youtube</a></li>
</ul></li>
<li>课程教材
<ul>
<li>Artificial intelligence: A Modern Approach</li>
</ul></li>
<li>课程作业
<ul>
<li><a href="https://inst.eecs.berkeley.edu/~cs188/fa18/index.html">CS188</a></li>
</ul></li>
</ul>
<h2 id="其他资料">其他资料</h2>
<p><a href="https://csdiy.wiki/">CS自学指南</a></p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>coding</tag>
        <tag>studying</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习——神经网络基本内容（01）</title>
    <url>/2018/01/04/deep-01/</url>
    <content><![CDATA[<h1 id="概述">概述</h1>
<p>深度学习几乎就等于神经网络算法，该算法主要由两个模块构成：前向传播（Forward Propagation）、后向传播（Backward Propagation）。</p>
<p>前向传播来计算预测值<span class="math inline">\(\hat{y}\)</span>，而后向传播则根据预测值与实际值的差别计算成本方程（Cost Function），并根据该值改进神经网络各节点的权重值。经过多次迭代，逐渐收敛。</p>
<span id="more"></span>
<h1 id="forward-propagation">Forward Propagation</h1>
<p>前向传播又有两个模块：线性模块、激发模块。</p>
<h2 id="线性模块">线性模块</h2>
<p>线性模块是本层神经节点根据输入<span class="math inline">\(X = \{X^{(1)}, X^{(2)}, ... , X^{(m)}\}\)</span>来计算输出： <span class="math display">\[
Z = WX + b
\]</span> 这里<span class="math inline">\(W\)</span>是本层神经节点的权重。有<span class="math inline">\(m\)</span>个样本的情况下，假设每个样本有<span class="math inline">\(n_x\)</span>个参数，即样本<span class="math inline">\(X\)</span>的维度为<span class="math inline">\((n_x, m)\)</span>。假设本层共有<span class="math inline">\(n^{[l]}\)</span>个神经节点，则<span class="math inline">\(W\)</span>的维度为<span class="math inline">\((n^{[l]}, n_x)\)</span>。进而，<span class="math inline">\(b\)</span>的维度为<span class="math inline">\((n^{[l]}, 1)\)</span>。</p>
<h2 id="激发模块">激发模块</h2>
<p>由于神经网络的输出值域等问题，由线性模块计算得到的输出不能直接作为整个模型的输出，而需要经过激发模块的处理。假设激发函数（Activation Function）为<span class="math inline">\(g(\bullet)\)</span>，则最终本层神经节点的输出为： <span class="math display">\[
A = g(Z)
\]</span></p>
<p>常用的激发函数有几种：</p>
<h3 id="sigmoid函数">sigmoid函数</h3>
<p>该函数的表达式为： <span class="math display">\[
\sigma (x) = \frac{1}{1 + e^{-x}}
\]</span> 该函数的图象为： <img src="/2018/01/04/deep-01/01.png" class="" title="Sigmoid函数图像"></p>
<p>从图像上可以看出，该函数的值域介于0，1之间，当处理分类问题（Classification）时，该函数能较好的进行最后的输出预测。 若<span class="math inline">\(a = \sigma (z)\)</span>，则该函数的导数为：<span class="math inline">\(\sigma&#39;(z) = a(1-a)\)</span></p>
<h3 id="tanh函数">tanh函数</h3>
<p>该函数的表达式为： <span class="math display">\[
\tanh(x) = \frac{e^x - e^{-x}}{e^x + e^{-x}}
\]</span> 函数图象为： <img src="/2018/01/04/deep-01/02.png" class="" title="tanh函数图象"></p>
<p>该函数图像与Sigmoid函数类似，唯一不同的是Sigmoid函数图像介于0，1之间，而tanh函数图像则介于-1，1之间。从实践来看，tanh函数作为激发函数表现总是要比sigmoid函数好。</p>
<p>若<span class="math inline">\(a = tanh(x)\)</span>，则该函数的导数<span class="math inline">\(tanh&#39;(x) = 1-a^2\)</span>。</p>
<p>但是，两函数都存在同一个问题：当自变量的值过大或过小时，如<span class="math inline">\(x = -1000\)</span>，此时，从图像上可以看出，函数的图像会变得十分扁平，意味着其导数会十分小，进而梯度下降法（Gradient Descent）对权重<span class="math inline">\(W\)</span>的改变会十分的有限。进而，该神经网络的训练可能会十分的漫长。</p>
<h3 id="relu函数">ReLU函数</h3>
<p>该函数就为改变上面两个函数的缺点诞生的，其表达式十分简单： <span class="math display">\[
f(x) =
\begin{cases}
x, &amp; x &gt; 0 \\\
0, &amp; else
\end{cases}
\]</span></p>
<p>其函数图象为： <img src="/2018/01/04/deep-01/03.png" class="" title="ReLU函数图象"></p>
<p>进而其导数也不存在上面两个函数的缺点，进而实践中，该函数的表现总是比以上两个函数都好。</p>
<h2 id="前向传播总结">前向传播总结</h2>
<p>用<span class="math inline">\(A^{[l-1]}\)</span>表示第<span class="math inline">\(l\)</span>层神经网络的输入值，即第<span class="math inline">\(l-1\)</span>层神经网络的激发值，其维度为<span class="math inline">\((n^{[l-1]}, m)\)</span>，其中<span class="math inline">\(n^{[l]}\)</span>表示该层神经网络的节点个数；用<span class="math inline">\(W^{[l]}\)</span>表示第<span class="math inline">\(l\)</span>层神经网络的权重，其维度为<span class="math inline">\((n^{[l]}, n^{[l-1]})\)</span>，则 <span class="math display">\[
Z^{[l]} = W^{[l]}A^{[l-1]} + b^{[l]}
\]</span> <span class="math display">\[
A^{[l]} = g(Z^{[l]})
\]</span> 其中，<span class="math inline">\(Z^{[l]}\)</span>和<span class="math inline">\(A^{[l]}\)</span>的维度均为<span class="math inline">\((n^{[l]}, m)\)</span></p>
<h1 id="损失函数loss-function和成本函数cost-function">损失函数（Loss Function）和成本函数（Cost Function）</h1>
<p>在正向传播和逆向传播之间还要先计算正向传播的损失（与实际值），再利用这个损失来进行逆向传播从而对权重进行修正。</p>
<p>损失函数是对于整体<span class="math inline">\(X\)</span>中的某一样本<span class="math inline">\(X^{(i)}\)</span>而言的，即有： <span class="math display">\[
L(X^{(i)}) = (\hat{y}^{(i)} - y)^2
\]</span> 而成本函数则是对整个整体<span class="math inline">\(X\)</span>而言的，即有： <span class="math display">\[
J(X) = \frac1{2m}\sum_{i=1}^{m}L(X^{(i)})
\]</span></p>
<p>可用如下的代码计算 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>/<span class="number">2</span>/m*np.<span class="built_in">sum</span>(np.square(yhat-y))</span><br></pre></td></tr></table></figure></p>
<h1 id="backward-propagation">Backward Propagation</h1>
<p>反向传播的基础是成本函数，下面用逻辑回归（Logistical Regression）做例子说明。</p>
<h2 id="一个例子逻辑回归">一个例子：逻辑回归</h2>
<p>逻辑回归下，一个常用的损失函数是： <span class="math display">\[
L(\hat{y}, y) = -(y\ln \hat{y} + (1-y)\ln(1-\hat{y}))
\]</span></p>
<p>当该神经网络一共有<span class="math inline">\(L\)</span>层时，该损失函数对<span class="math inline">\(A^{[L]}\)</span>的导数即为： <span class="math display">\[
\frac{dL}{dA^{[L]}} = -\frac{y}{A^{[L]}} + \frac{1-y}{1-A^{[L]}}
\]</span> 已知<span class="math inline">\(dA^{[L]}/dZ^{[L]} = A^{[L]}(1-A^{[L]})\)</span>，则 <span class="math display">\[
\begin{aligned}
    \frac{dL}{dZ^{[L]}} &amp;= \frac{dL}{dA^{[L]}}\frac{dA^{[L]}}{dZ^{[L]}} \\\
    &amp;= A^{[L]} - Y
\end{aligned}
\]</span></p>
<p>又由于<span class="math inline">\(Z^{[L]} = W^{[L]}A^{[L-1]} + b^{[L]}\)</span>，则 <span class="math display">\[
\frac{dZ^{[L]}}{dW^{[L]}} = A^{[L-1]T}
\]</span> 那么，根据链式求导法则有： <span class="math display">\[
\begin{aligned}
    \frac{dL}{dW^{[L]}} &amp;= \frac{dL}{dZ^{[L]}}\frac{dZ^{[L]}}{dW^{[L]}} \\\
    &amp;= (A^{[L]} - Y)A^{[L-1]T}
\end{aligned}
\]</span> 进而对第<span class="math inline">\(L\)</span>层神经网络有 <span class="math display">\[
\frac{dJ}{dW^{[L]}} = \frac{1}{m}(A^{[L]}-Y)A^{[L-1]T}
\]</span> <span class="math display">\[
\frac{dJ}{db^{[L]}} = \frac{1}{m}\sum(A^{[L]}-Y)
\]</span> 对任意第<span class="math inline">\(l\)</span>层神经网络有 <span class="math display">\[
\begin{aligned}
    \frac{dJ}{dZ^{[l]}} &amp;= \frac{dJ}{dZ^{[l+1]}}\frac{dZ^{[l+1]}}{dZ^{[l]}} \\\
    &amp;= \frac{dJ}{dZ^{[l+1]}}\frac{dZ^{[l+1]}}{dA^{[l]}}\frac{dA^{[l]}}{dZ^{[l]}} \\\
    &amp;= W^{[l]T}\frac{dJ}{dZ^{[l+1]}}\times g&#39;(Z^{[l]})
\end{aligned}
\]</span> 进而，有 <span class="math display">\[
\begin{aligned}
    \frac{dJ}{dW^{[l]}} &amp;= \frac{dJ}{dZ^{[l]}}\frac{dZ^{[l]}}{dW^{[l]}} \\\
    &amp;= \frac1m\frac{dJ}{dZ^{[l]}}A^{[l-1]T}
\end{aligned}
\]</span> <span class="math display">\[
\begin{aligned}
    \frac{dJ}{db^{[l]}} &amp;= \frac{dJ}{dZ^{[l]}}\frac{dZ^{[l]}}{db^{[l]}} \\\
    &amp;= \frac1m\sum\frac{dJ}{dZ^{[l]}}
\end{aligned}
\]</span></p>
<h2 id="反向传播总结">反向传播总结</h2>
<p>反向传播的关键是计算<span class="math inline">\(\frac{dJ}{dZ^{[l]}}\)</span>，当用<span class="math inline">\(d(\bullet)\)</span>表示<span class="math inline">\(\frac{dJ}{d(\bullet)}\)</span>时，可表示为： <span class="math display">\[
\begin{aligned}
    dZ^{[l]} &amp;= W^{[l]T}dZ^{[l+1]}\times g&#39;(Z^{[l]}) \\\
    dW^{[l]} &amp;= \frac1mdZ^{[l]}A^{[l-1]T} \\\
    db^{[l]} &amp;= \frac1m\sum dZ^{[l]}
\end{aligned}
\]</span></p>
<h2 id="更新变量">更新变量</h2>
<p>运用梯度下降法计算时，还要更新变量。一般而言，为了保证算法的收敛，需要设定一个学习速率（Learning Rate）来控制神经网络的更新。学习速率（用<span class="math inline">\(\alpha\)</span>来表示）作为一个超参数（Hyperparameter）需要我们不断进行测试来确定其最佳值。前文需要确定的神经网络层数<span class="math inline">\(L\)</span>也是一个需要不断调整确定最佳值的超参数。 <span class="math display">\[
\begin{aligned}
    W^{[l]} &amp;= W^{[l]} - \alpha dW^{[l]} \\\
    b^{[l]} &amp;= b^{[l]} - \alpha db^{[l]}
\end{aligned}
\]</span></p>
<h1 id="神经网络的训练">神经网络的训练</h1>
<p>经过上述从正向传播到计算成本函数，到进行反向传播后的一个完整循环成为一个epoch。一般而言，随着完成的epoch次数的增加，成本函数（在训练集上）一直呈下降趋势，并最终收敛于一个稳定值（但此时并非一定达到了全局最优解，有可能是局部最优解）：若与此同时，在测试集上的误差也较低，则神经网络训练较好；若训练集上误差很小，但是测试集上的误差较大，此时神经网络有较大的方差（Variance），或称为过拟合（Overfitting）；若训练集上的误差也很大，此时神经网络有较大的偏差（Bias），或称为欠拟合（underfitting）。</p>
<p>一般而言，欠拟合的解决方法是： - 调整超参数 - 训练更深的神经网络（即增加神经网络层数）</p>
<p>而过拟合的解决方法是： - 收集更多的数据来进行训练 - 正则化（Regularization） - 标准化（Normalization）</p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Neural Network</tag>
      </tags>
  </entry>
  <entry>
    <title>深度学习——神经网络超参数的处理（02）</title>
    <url>/2018/01/05/deep-02/</url>
    <content><![CDATA[<h1 id="概述">概述</h1>
<p>本文建立在<a href="https://junkuizhang.github.io/2018/01/04/deep-01/">前一篇文章</a>的基础上进行讨论，这<a href="https://junkuizhang.github.io/categories/深度学习/">一系列文章</a>的本意是记录本人的学习历程，避免“后面学，前面忘”的窘境。</p>
<p>前文讨论到超参数，本文继续讨论如何处理上文的问题。具体而言，主要涉及到： - 对欠拟合、过拟合的处理 - 正则化方法（Regularization） - <span class="math inline">\(L2\)</span>正则化 - Dropout正则化 - 标准化方法（Normalization） - 梯度消失（Vanishing Gradient） - 梯度爆炸（Exploding Gradient） - 梯度检查（Gradient Checking）</p>
<span id="more"></span>
<h1 id="神经网络训练数据">神经网络训练数据</h1>
<p>深度学习的火爆离不开现如今的大量数据以及Tensorflow之类算力的加成buff，一般把数据分为训练集、开发集、测试集（Train/Dev/Test sets）。</p>
<h2 id="数据集">数据集</h2>
<p>训练集就是训练神经网络的数据集，一般而言越多越好；开发集则一般用来调参，因此最终神经网络实际上是包含了训练集和开发集的信息，因此开发集上的测试结果并不是无偏的；测试集则用来测试训练好的神经网络，结果也是无偏的。</p>
<p>一般而言，当数据量较少时（<span class="math inline">\(&lt;2000\)</span>），训练集、开发集、测试集的比例一般为<span class="math inline">\(6:2:2\)</span>。这三个数据集中测试集可以没有，这样的话开发集实际上充当了测试集的功能。但由于上面提到的原因，开发集并不完全等价于测试集。</p>
<p>当数据量很大时，比如<span class="math inline">\(1,000,000\)</span>，这时，并不一定要按照<span class="math inline">\(6:2:2\)</span>的比例来划分。由于开发集、测试集的功能，其并不需要很多的数据，因此给两者分配一定数量的数据可以完成目标就可以了。因此，可以按照<span class="math inline">\(98:1:1\)</span>的比例来分配数据。</p>
<h2 id="数据量">数据量</h2>
<p>当数据量很大时，神经网络将变得十分臃肿，进而拖慢训练速度。比如，当数据量为<span class="math inline">\(1,000,000\)</span>时，我们可以把整个数据集<span class="math inline">\(X\)</span>分为1000个小数据集<span class="math inline">\(X^{\\{i\\}}\)</span>，每个小数据集包含1000个数据。</p>
<p>当神经网络在<span class="math inline">\(X^{\\{i\\}}\)</span>上完成一次训练，便进行一次参数更新：即原本要跑完<span class="math inline">\(1,000,000\)</span>条数据才会更新参数，现在每跑完一小部分数据就更新一次参数。在<span class="math inline">\(X^{\\{i\\}}\)</span>上跑完一次，成为完成了一次epoch。</p>
<h1 id="初始化参数">初始化参数</h1>
<p>这里的参数指<span class="math inline">\(W^{[l]}\)</span>和<span class="math inline">\(b^{[l]}\)</span>，运用“He initialization”可以更快的使模型收敛。具体而言，只需要在常规初始化的参数后面乘上<span class="math inline">\(\sqrt{2/n^{[l-1]}}\)</span>即可。用代码表示为： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">parameters[<span class="string">&#x27;W&#x27;</span>+<span class="built_in">str</span>(l)] = np.random.randn(layers_dims[l], layers_dims[l-<span class="number">1</span>])*np.sqrt(<span class="number">2</span>/layers_dims[l-<span class="number">1</span>])</span><br><span class="line">parameters[<span class="string">&#x27;b&#x27;</span>+<span class="built_in">str</span>(l)] = np.zeros((layers_dims[l], <span class="number">1</span>))</span><br></pre></td></tr></table></figure></p>
<h1 id="欠拟合与过拟合">欠拟合与过拟合</h1>
<p>前文提到，区分两者的关键是模型在训练集和测试集上的表现： - 欠拟合：训练集误差大，测试集误差较小 - 过拟合：训练集误差小，测试集误差较大 - 同时发生：训练集、测试集上误差均较大</p>
<p>处理欠拟合的方法有： - 增加神经网络深度 - 调整超参数</p>
<p>处理过拟合的方法有： - 正则化 - 标准化</p>
<h2 id="l2正则化regularization"><span class="math inline">\(L2\)</span>正则化（Regularization）</h2>
<p>一般而言，避免过拟合的标准方法是<span class="math inline">\(L2\)</span>正则化，它从改变成本函数开始。 正常的成本函数是： <span class="math display">\[
J = -\frac1m\sum_{i=1}^{m}(y^{(i)}\ln(a^{[L](i)}) + (1-y^{(i)})\ln(1-a^{[L](i)}))
\]</span></p>
<p>改变为： <span class="math display">\[
J = -\frac1m\sum_{i=1}^{m}(y^{(i)}\ln(a^{[L](i)})+(1-y^{(i)})\ln(1-a^{[L](i)})) + \frac1m\frac\lambda2\sum_l\sum_k\sum_jW_{k,j}^{[l]2}
\]</span></p>
<p>这里<span class="math inline">\(\lambda\)</span>成为正则化常数，是一个需要我们不断测试来选择最佳值的超参数。</p>
<p>进而，反向传播的计算公式也有所改变： <span class="math display">\[
\begin{aligned}
    dW^{[l]} &amp;= \frac1mdZ^{[l]}A^{[l-1]T} + \frac{\lambda}{m}\times W^{[l]} \\\
    db^{[l]} &amp;= \frac1m\sum\_{row}dZ^{[l]}
\end{aligned}
\]</span></p>
<h2 id="dropout">Dropout</h2>
<p>Dropout也是常用的一种正则化手段，其在每次迭代过程中随机关闭一些神经节点，看起来不可思议，问题是它居然真的有用。</p>
<p>代码中通过一个由0和1为元素构成的矩阵来实现神经节点的开关。 <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">Dl = np.random.rand(Al.shape[<span class="number">0</span>], Al.shape[<span class="number">1</span>]) <span class="comment">#随机产生0-1间的数字</span></span><br><span class="line">Dl = (Dl &lt; keep_prob) <span class="comment">#keep_prob是保持概率，小于这个数的将被设置为1</span></span><br><span class="line">Al *= Dl</span><br><span class="line">Al /= keep_prob</span><br></pre></td></tr></table></figure></p>
<h2 id="规范化normalization">规范化（Normalization）</h2>
<p>也称为标准化，是对输入数据进行的处理：把输入数据的均值变为0，方差变为1。 <span class="math display">\[
\begin{aligned}
    X &amp;= X - \bar{X} \\\
    X &amp;= \frac{X}{\sqrt{Var(X)}}
\end{aligned}
\]</span></p>
<p>经过这样的处理后，模型收敛速度更快。</p>
<h2 id="梯度检测gradient-checking">梯度检测（Gradient Checking）</h2>
<p>根据导数的定义，即 <span class="math display">\[
f&#39;(x) = \lim_{\epsilon\rightarrow0}\frac{f(x+\epsilon)-f(x)}{\epsilon}
\]</span></p>
<p>进而赋予<span class="math inline">\(\epsilon\)</span>一个很小的值来近似计算倒数来比较。</p>
<h1 id="算法优化">算法优化</h1>
<h2 id="数据量-1">数据量</h2>
<p>这里是指前文提到的，当数据量很大时，把整体数据<span class="math inline">\(X\)</span>分成一些小数据集<span class="math inline">\(X^{\\{i\\}}\)</span>，在小数据集上训练数据。</p>
<h2 id="动量法momentum">动量法（Momentum）</h2>
<p>动量法可以纠正梯度下降法的frustration。</p>
<h3 id="初始化动量">初始化动量</h3>
<p>动量<span class="math inline">\(v\)</span>的维度应该和参数相同，具体而言： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">initialize_velocity</span>(<span class="params">parameters</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    参数：</span></span><br><span class="line"><span class="string">    parameters -- 包含参数W和b的python字典</span></span><br><span class="line"><span class="string">                  Wl = parameters[&#x27;W&#x27;+str(l)]</span></span><br><span class="line"><span class="string">		  bl = parameters[&#x27;b&#x27;+str(l)]</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">    返回值：</span></span><br><span class="line"><span class="string">    v -- 包含计算好的动量的python字典</span></span><br><span class="line"><span class="string">         dWl的动量 = v[&#x27;dW&#x27;+str(l)]</span></span><br><span class="line"><span class="string">	 dbl的动量 = v[&#x27;db&#x27;+str(l)]</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    L = <span class="built_in">len</span>(parameters) // <span class="number">2</span></span><br><span class="line">    v = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">        v[<span class="string">&#x27;dW&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)] = np.zeros(parameters[<span class="string">&#x27;W&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)].shape)</span><br><span class="line">	v[<span class="string">&#x27;db&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)] = np.zeros(parameters[<span class="string">&#x27;b&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)].shape)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> v</span><br></pre></td></tr></table></figure></p>
<h3 id="更新参数wb">更新参数W，b</h3>
<p>更新参数<span class="math inline">\(W\)</span>和<span class="math inline">\(b\)</span>的规则为： <span class="math display">\[
\begin{cases}
    v_{dW^{[l]}} = \beta v_{dW^{[l]}} + (1-\beta)dW^{[l]} \\\
    W^{[l]} = W^{[l]} - \alpha v_{dW^{[l]}}
\end{cases}
\]</span> <span class="math display">\[
\begin{cases}
    v_{db^{[l]}} = \beta v_{db^{[l]}} + (1-\beta)db^{[l]} \\\
    b^{[l]} = b^{[l]} - \alpha v_{db^{[l]}}
\end{cases}
\]</span></p>
<p>对应的代码为: <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">update</span>(<span class="params">parameters, grads, v, beta, learning_rate</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    参数：</span></span><br><span class="line"><span class="string">    parameters -- Wl = parameters[&#x27;W&#x27;+str(l)]</span></span><br><span class="line"><span class="string">                  bl = parameters[&#x27;b&#x27;+str(l)]</span></span><br><span class="line"><span class="string">    grads -- dWl = grads[&#x27;dW&#x27;+str(l)]</span></span><br><span class="line"><span class="string">             dbl = grads[&#x27;db&#x27;+str(l)]</span></span><br><span class="line"><span class="string">    beta -- 常量，动量法的一个超参数</span></span><br><span class="line"><span class="string">    learning_rate -- 常量，学习速率</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    返回值：</span></span><br><span class="line"><span class="string">    parameters -- 同上，更新后的参数</span></span><br><span class="line"><span class="string">    v -- 保存计算好的动量值的字典</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    L = <span class="built_in">len</span>(parameters) // <span class="number">2</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">        v[<span class="string">&#x27;dW&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)] = beta * v[<span class="string">&#x27;dW&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)] + (<span class="number">1</span> - beta) * grads[<span class="string">&#x27;dW&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)]</span><br><span class="line">	v[<span class="string">&#x27;db&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)] = beta * v[<span class="string">&#x27;db&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)] + (<span class="number">1</span> - beta) * grads[<span class="string">&#x27;db&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">	parameters[<span class="string">&#x27;W&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)] -= learning_rate * v[<span class="string">&#x27;dW&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)]</span><br><span class="line">	parameters[<span class="string">&#x27;b&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)] -= learning_rate * v[<span class="string">&#x27;db&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> parameters, v</span><br></pre></td></tr></table></figure></p>
<p>一般而言，<span class="math inline">\(\beta\)</span>的值一般选取0.8到0.999之间的某个数，<span class="math inline">\(\beta = 0.9\)</span>是一个常用的数。</p>
<h2 id="adam优化法">Adam优化法</h2>
<p>Adam法结合了动量法和RMSProp，是效率较高的一种优化方法。 其数学表示如下： <span class="math display">\[
\begin{cases}
     v_{dW^{[l]}} = \beta_1v_{dW^{[l]}} + (1-\beta_1)dW^{[l]} \\\
     v_{dW^{[l]}}^{corrected} = \frac{v_{dW^{[l]}}}{1 - (\beta_1)^t} \\\
     s_{dW^{[l]}} = \beta_2s_{dW^{[l]}} + (1-\beta_2)(dW^{[l]})^2 \\\
     s_{dW^{[l]}}^{corrected} = \frac{s_{dW^{[l]}}}{1 - (\beta_2)^t} \\\
     W^{[l]} = W^{[l]} - \alpha \frac{v_{dW^{[l]}}^{corrected}}{\sqrt{s_{dW^{[l]}}^{corrected}}+\epsilon}
\end{cases}
\]</span></p>
<p>这里： - <span class="math inline">\(t\)</span>表示Adam算法的运行次数 - <span class="math inline">\(\beta_1\)</span>和<span class="math inline">\(\beta_2\)</span>是两个超参数 - <span class="math inline">\(\epsilon\)</span>是一个非常小的常数，其主要目的是防止分母部分为零</p>
<p>代码如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">update_parameters</span>(<span class="params">parameters, grads, v, s, t, learning_rate=<span class="number">0.01</span>, beta1=<span class="number">0.9</span>, beta2=<span class="number">0.999</span>, epsilon=<span class="number">1e-8</span></span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    输入：</span></span><br><span class="line"><span class="string">    parameters -- 包含W和b的字典</span></span><br><span class="line"><span class="string">    grads -- 包含梯度的字典</span></span><br><span class="line"><span class="string">    v -- Adam法的动量部分一</span></span><br><span class="line"><span class="string">    s -- Adam法的栋梁部分二</span></span><br><span class="line"><span class="string">    t -- Adam法的执行次数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    返回值：</span></span><br><span class="line"><span class="string">    parameters -- 调整后的参数字典</span></span><br><span class="line"><span class="string">    v, b -- 同上</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    L = <span class="built_in">len</span>(parameters) // <span class="number">2</span></span><br><span class="line">    v_corrected = &#123;&#125;</span><br><span class="line">    s_corrected = &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(L):</span><br><span class="line">        v[<span class="string">&#x27;dW&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)] = beta1 * v[<span class="string">&#x27;dW&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)] + (<span class="number">1</span> - beta1) * grads[<span class="string">&#x27;dW&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)]</span><br><span class="line">	v[<span class="string">&#x27;db&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)] = beta1 * v[<span class="string">&#x27;db&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)] + (<span class="number">1</span> - beta1) * grads[<span class="string">&#x27;bd&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)]</span><br><span class="line"></span><br><span class="line">	v_corrected[<span class="string">&#x27;dW&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)] = v[<span class="string">&#x27;dW&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)] / (<span class="number">1</span> - np.power(beta1, t))</span><br><span class="line">	v_corrected[<span class="string">&#x27;db&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)] = v[<span class="string">&#x27;db&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)] / (<span class="number">1</span> - np.power(beta1, t))</span><br><span class="line"></span><br><span class="line">	s[<span class="string">&#x27;dW&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)] = beta2 * s[<span class="string">&#x27;dW&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)] + (<span class="number">1</span> - beta2) * np.power(grads[<span class="string">&#x27;dW&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)], <span class="number">2</span>)</span><br><span class="line">	s[<span class="string">&#x27;db&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)] = beta2 * s[<span class="string">&#x27;db&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)] + (<span class="number">1</span> - beta2) * np.power(grads[<span class="string">&#x27;db&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)], <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">	s_corrected[<span class="string">&#x27;dW&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)] = s[<span class="string">&#x27;dW&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)] / (<span class="number">1</span> - np.power(beta2, t))</span><br><span class="line">	s_corrected[<span class="string">&#x27;db&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)] = s[<span class="string">&#x27;db&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)] / (<span class="number">1</span> - np.power(beta2, t))</span><br><span class="line"></span><br><span class="line">	parameters[<span class="string">&#x27;dW&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)] -= learning_rate * v_corrected[<span class="string">&#x27;dW&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)] / (np.sqrt(s_corrected[<span class="string">&#x27;dW&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)]) + epsilon)</span><br><span class="line">	parameters[<span class="string">&#x27;db&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)] -= learning_rate * v_corrected[<span class="string">&#x27;db&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)] / (np.sqrt(s_corrected[<span class="string">&#x27;db&#x27;</span>+<span class="built_in">str</span>(l+<span class="number">1</span>)]) + epsilon)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> parameters, v, s</span><br></pre></td></tr></table></figure></p>
<h1 id="超参数的调整">超参数的调整</h1>
<h2 id="超参数">超参数</h2>
<p>常见的超参数按重要性分类： - 重要性No.1 - 学习速率<span class="math inline">\(\alpha\)</span> - 重要性No.2 - 动量法参数<span class="math inline">\(\beta\)</span>，常用<span class="math inline">\(\beta=0.9\)</span> - 隐藏层的神经单元数量 - 每个小的数据集<span class="math inline">\(X^{\\{i\\}}\)</span>包含的数据量，多为2的倍数，如64，256 - 重要性No.3 - 神经网络的深度 - 学习速率递减参数 - 不那么重要 - Adam优化法参数，<span class="math inline">\(\beta_1=0.9, , \beta_2=0.999, , \epsilon = 10^{-8}\)</span></p>
<h2 id="调参的一般方法">调参的一般方法</h2>
<p>随机选取参数进行训练并观察结果是一般方法，要注意的是不能简单的取随机数。</p>
<p>比如学习速率<span class="math inline">\(\alpha\)</span>的范围一般取<span class="math inline">\(\alpha \in (0.001, 0.1)\)</span>，但是，下面这样的做法是不可取的： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">alpha = np.random.rand() * 0099 + <span class="number">0.001</span></span><br></pre></td></tr></table></figure> 下面的方法是可取的： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line">beta = -<span class="number">1</span> - np.random.rand() * <span class="number">2</span></span><br><span class="line">alpha = np.power(<span class="number">10</span>, beta)</span><br></pre></td></tr></table></figure></p>
<h2 id="batch-norm">Batch Norm</h2>
<p>BN是一种与之前的规范会类似的方法。前文说到的规范化是针对输入的，这里则是针对所有的<span class="math inline">\(Z^{[l]}\)</span>做的处理。</p>
<h2 id="多种类分类器multi-class-classification">多种类分类器（Multi-class Classification）</h2>
<h3 id="softmax回归">Softmax回归</h3>
<p>与之前的二元分类器类似，当有<span class="math inline">\(n^{[L]}\)</span>个种类时，这里的输出是一个<span class="math inline">\((n^{[L]}, 1)\)</span>矩阵。具体而言： <span class="math display">\[
\begin{aligned}
    Z^{[L]} &amp;= [...] \\\
    Z_{temp}^{[L]} &amp;= e^{Z^{[L]}} \\\
    A^{[L]} &amp;= \frac{Z_{temp}^{[L]}}{\sum Z_{temp}^{[L]}}
\end{aligned}
\]</span></p>
<p>Softmax是与Hardmax相对的，Hardmax是直接把<span class="math inline">\(Z^{[L]}\)</span>中最大的输出直接赋值为1，其余赋值为0。因该方法简单直接，因而被赋予Hard之名，Softmax较为柔和。</p>
<h1 id="tensorflow">Tensorflow</h1>
<p>Tensorflow作为Google的开源机器学习框架，可以很方便的帮助我们部署机器学习的内容，尤其是其可以自动计算Backward Propagation部分。</p>
]]></content>
      <categories>
        <category>深度学习</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Neural Network</tag>
      </tags>
  </entry>
  <entry>
    <title>人工智能教我学习</title>
    <url>/2023/01/03/gpt_awesome/</url>
    <content><![CDATA[<p>ChatGPT真是太厉害了！</p>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>Testing</tag>
        <tag>GPT</tag>
      </tags>
  </entry>
  <entry>
    <title>黑苹果</title>
    <url>/2024/01/28/hackintosh/</url>
    <content><![CDATA[<h1 id="记得分好区">记得分好区！</h1>
<p>第一步一定是分区，要至少200M的EFI分区，格式为FAT32。如果采用微PE安装Windows，也要给Windows提前分好EFI分区和安装的分区。</p>
<span id="more"></span>
<h1 id="macos配置">macOS配置</h1>
<h2 id="v2ray">v2ray</h2>
<p>把下载好的v2raya和v2ray移动到如下地址： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> /usr/local/bin/</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p /usr/local/share/v2ray/</span><br><span class="line"><span class="built_in">mkdir</span> ~/Library/LaunchAgents/</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mv</span> v2raya /usr/local/bin/</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">mv</span> v2ray /usr/local/bin/</span><br><span class="line"></span><br><span class="line"><span class="built_in">mv</span> geoip.dat ~/Library/Application\ Support/v2ray/geoip.dat</span><br><span class="line"><span class="built_in">mv</span> geosite.dat ~/Library/Application\ Support/v2ray/geosite.dat</span><br><span class="line"></span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chmod</span> 755 /usr/local/bin/v2ray</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chmod</span> 755 /usr/local/bin/v2raya</span><br></pre></td></tr></table></figure></p>
<p>新建服务文件并保存到<code>~/Library/LaunchAgents/</code></p>
<p>如：<code>vim ~/Library/LaunchAgents/org.v2raya.v2raya.plist</code></p>
<p>内容如下： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span><br><span class="line">&lt;!DOCTYPE plist PUBLIC <span class="string">&quot;-//Apple//DTD PLIST 1.0//EN&quot;</span> <span class="string">&quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd&quot;</span>&gt;</span><br><span class="line">&lt;plist version=<span class="string">&quot;1.0&quot;</span>&gt;</span><br><span class="line">&lt;dict&gt;</span><br><span class="line">      &lt;key&gt;EnvironmentVariables&lt;/key&gt;</span><br><span class="line">      &lt;dict&gt;</span><br><span class="line">            &lt;key&gt;V2RAYA_LOG_FILE&lt;/key&gt;</span><br><span class="line">            &lt;string&gt;/tmp/v2raya.<span class="built_in">log</span>&lt;/string&gt;</span><br><span class="line">            &lt;key&gt;V2RAYA_V2RAY_BIN&lt;/key&gt;</span><br><span class="line">            &lt;string&gt;/usr/local/bin/v2ray&lt;/string&gt;</span><br><span class="line">      &lt;/dict&gt;</span><br><span class="line">      &lt;key&gt;KeepAlive&lt;/key&gt;</span><br><span class="line">      &lt;<span class="literal">true</span>/&gt;</span><br><span class="line">      &lt;key&gt;Label&lt;/key&gt;</span><br><span class="line">      &lt;string&gt;org.v2raya.v2raya&lt;/string&gt;</span><br><span class="line">      &lt;key&gt;ProgramArguments&lt;/key&gt;</span><br><span class="line">      &lt;array&gt;</span><br><span class="line">            &lt;string&gt;/usr/local/bin/v2raya&lt;/string&gt;</span><br><span class="line">            &lt;string&gt;--lite&lt;/string&gt;</span><br><span class="line">      &lt;/array&gt;</span><br><span class="line">      &lt;key&gt;RunAtLoad&lt;/key&gt;</span><br><span class="line">      &lt;<span class="literal">true</span>/&gt;</span><br><span class="line">&lt;/dict&gt;</span><br><span class="line">&lt;/plist&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="运行">运行</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">launchctl load ~/Library/LaunchAgents/org.v2raya.v2raya.plist</span><br></pre></td></tr></table></figure>
<p>如果要关掉v2rayA服务，将上述命令从<code>load</code>替换为<code>unload</code>即可。可以通过Web前端查看日志。</p>
<p>Web前端地址为：<code>localhost:2017</code></p>
<h1 id="配置git代理">配置git代理</h1>
<p>设置全局代理： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global http.proxy socks5://127.0.0.1:20170</span><br><span class="line">git config --global https.proxy socks5://127.0.0.1:20170</span><br></pre></td></tr></table></figure></p>
<p>针对某项目，在根目录下： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --<span class="built_in">local</span> http.proxy socks5://127.0.0.1:20170</span><br><span class="line">git config --<span class="built_in">local</span> https.proxy socks5://127.0.0.1:20170</span><br></pre></td></tr></table></figure></p>
<p>查看代理配置情况： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global --get http.proxy</span><br><span class="line">git config --global --get https.proxy</span><br></pre></td></tr></table></figure></p>
<p>取消代理： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global --<span class="built_in">unset</span> http.proxy</span><br><span class="line">git config --global --<span class="built_in">unset</span> https.proxy</span><br></pre></td></tr></table></figure></p>
<h1 id="配置homebrew">配置Homebrew</h1>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/bin/bash -c <span class="string">&quot;<span class="subst">$(curl -fsSL https://gitee.com/ineo6/homebrew-install/raw/master/install.sh)</span>&quot;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>macOS</category>
      </categories>
      <tags>
        <tag>studying</tag>
        <tag>hackintosh</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2017/01/01/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="quick-start">Quick Start</h2>
<h3 id="create-a-new-post">Create a new post</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="run-server">Run server</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="generate-static-files">Generate static files</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="deploy-to-remote-sites">Deploy to remote sites</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>Life is Strange</title>
    <url>/2019/05/18/lifs-is-strange/</url>
    <content><![CDATA[<h2 id="life-is-strange-is-it-not">Life is strange, is it not?</h2>
<span id="more"></span>
<p>You wake up everyday not knowing what's in store.</p>
<p> </p>
<p>You go to sleep only to journey yet again.</p>
<p> </p>
<p>Our universe is so vast and yet it is so detailed.</p>
<p> </p>
<p>Everthing has a story, including you.</p>
<p> </p>
<p>You may not be the first person to exists.</p>
<p> </p>
<p>You definately won't be the last.</p>
<p> </p>
<p>But you are the only you that exists.</p>
<p> </p>
<p>You're unique from everyone else in your own special way.</p>
<p> </p>
<p>Life is a journey.</p>
<p> </p>
<p>You will hit many bumps along the way.</p>
<p> </p>
<p>But you'll keep moving on.</p>
<p> </p>
<p>As cheesy as it sounds it's not the destination that matters, it's the journey.</p>
<p> </p>
<p>That's what makes life so wonderful.</p>
<p> </p>
<p>The good and the bad moments we go through.</p>
<p> </p>
<p>The people we meet.</p>
<p> </p>
<p>The places we go.</p>
<p> </p>
<p>And the goals we accomplish.</p>
<p> </p>
<p>It shows how incredible we can be and what we can do if we keep pushing on.</p>
<p> </p>
<p>If we keep on living.</p>
<p> </p>
<p>If you keep being you.</p>
<p> </p>
<p>So life may be strange but it's also very beautiful and you are a part of it.</p>
<p> </p>
<p>So live your life the way you want to.</p>
<p> </p>
<p>Do what you wanna do.</p>
<p> </p>
<p>Be who you wanna be.</p>
<p> </p>
<p>Just be you and never stop being you.</p>
<p> </p>
<p>So don't cry.</p>
<p> </p>
<p>Keep pushing on.</p>
<p> </p>
<p>And smile for all of the universe to see.</p>
<p> </p>
<p>So I wish you the best on your journey through this strange thing we call life.</p>
<p> </p>
<p>Peace</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>nothing</tag>
      </tags>
  </entry>
  <entry>
    <title>对宏观经济贫富差距的简单分析</title>
    <url>/2020/01/13/macro25/</url>
    <content><![CDATA[<h1 id="概述">概述</h1>
<h1 id="模型">模型</h1>
<h2 id="python中的线性规划求解">Python中的线性规划求解</h2>
<blockquote>
<p>本部分内容引自《数学建模算法与应用》</p>
</blockquote>
<p>求解如下的线性规划问题：</p>
<p><span class="math display">\[
min \quad z = 2x_1+3x_2+x_3
\]</span></p>
<p><span class="math display">\[
\begin{aligned}
s.t. \quad x_1+x_2+x_3&amp;=7 \\\
x_1+4x_2+2x_3&amp;\geq8 \\\
3x_1+2x_2&amp;\geq6 \\\
x_1,x_2,x_3&amp;\geq0
\end{aligned}
\]</span></p>
<p>用Python进行线性规划求解时，</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> optimize</span><br><span class="line"></span><br><span class="line">z = np.array([<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>])</span><br><span class="line">a = np.array([[<span class="number">1</span>, <span class="number">4</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">2</span>, <span class="number">0</span>]]</span><br><span class="line">b = np.array([<span class="number">8</span>, <span class="number">6</span>])</span><br><span class="line">a_eq = np.array([[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]])</span><br><span class="line">b_eq = np.array([<span class="number">7</span>])</span><br><span class="line">x1_bound = x2_bound = x3_bound = (<span class="number">0</span>, <span class="literal">None</span>)</span><br><span class="line">bounds = (x1_bound, x2_bound, x3_bound)</span><br><span class="line"></span><br><span class="line">res = optimize.linprog(z, A_ub=-a, b_ub=-b, A_eq=a_eq, b_eq=b_eq, bounds=bounds)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br></pre></td></tr></table></figure>
<h2 id="python中的非线性规划求解">Python中的非线性规划求解</h2>
<p>详见scipy的<a href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.optimize.minimize.html">官方文档</a>。</p>
<p>考虑如下的非线性规划问题：</p>
<p>计算<span class="math inline">\((2+x_1)/(1+x_2)-3x_1+4x_3\)</span>的最小值，这里对任意<span class="math inline">\(x_i\)</span>均有<span class="math inline">\(0.1&lt;x_i&lt;0.9\)</span>成立。</p>
<p>Python代码如下： <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> optimize</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义目标函数</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>(<span class="params">nums</span>):</span><br><span class="line">    a, b, c, d = nums</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_func0</span>(<span class="params">x</span>):</span><br><span class="line">        y = (a+x[<span class="number">0</span>])/(b+x[<span class="number">1</span>]) - c*x[<span class="number">0</span>] + d*x[<span class="number">2</span>]</span><br><span class="line">	<span class="keyword">return</span> y</span><br><span class="line">    <span class="keyword">return</span> _func0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 有两种方法表示约束</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">cons1</span>(<span class="params">nums</span>):</span><br><span class="line">    <span class="comment"># &#x27;eq&#x27;表示等式，&#x27;ineq&#x27;表示大于等于</span></span><br><span class="line">    x1_min, x1_max, x1_min, x2_max, x3_min, x3_max = nums</span><br><span class="line">    _cons = (&#123;<span class="string">&#x27;type&#x27;</span>:<span class="string">&#x27;ineq&#x27;</span>, <span class="string">&#x27;fun&#x27;</span>:<span class="keyword">lambda</span> x: x[<span class="number">0</span>]-x1_min&#125;,</span><br><span class="line">             &#123;<span class="string">&#x27;type&#x27;</span>:<span class="string">&#x27;ineq&#x27;</span>, <span class="string">&#x27;fun&#x27;</span>:<span class="keyword">lambda</span> x: x1_max-x[<span class="number">0</span>]&#125;，</span><br><span class="line">	     &#123;<span class="string">&#x27;type&#x27;</span>:<span class="string">&#x27;ineq&#x27;</span>, <span class="string">&#x27;fun&#x27;</span>:<span class="keyword">lambda</span> x: x[<span class="number">1</span>]-x2_min&#125;,</span><br><span class="line">	     &#123;<span class="string">&#x27;type&#x27;</span>:<span class="string">&#x27;ineq&#x27;</span>, <span class="string">&#x27;fun&#x27;</span>:<span class="keyword">lambda</span> x: x2_max-x[<span class="number">1</span>]&#125;,</span><br><span class="line">	     &#123;<span class="string">&#x27;type&#x27;</span>:<span class="string">&#x27;ineq&#x27;</span>, <span class="string">&#x27;fun&#x27;</span>:<span class="keyword">lambda</span> x: x[<span class="number">2</span>]-x3_min&#125;,</span><br><span class="line">	     &#123;<span class="string">&#x27;type&#x27;</span>:<span class="string">&#x27;ineq&#x27;</span>, <span class="string">&#x27;fun&#x27;</span>:<span class="keyword">lambda</span> x: x3_max-x[<span class="number">2</span>]&#125;)</span><br><span class="line">    <span class="keyword">return</span> _cons</span><br><span class="line"></span><br><span class="line"><span class="comment"># 法2</span></span><br><span class="line">bouds = []</span><br><span class="line"><span class="keyword">for</span> k <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">3</span>):</span><br><span class="line">    <span class="comment"># &#x27;None&#x27;为不限制</span></span><br><span class="line">    bounds.append((<span class="number">0.1</span>, <span class="number">0.9</span>))</span><br><span class="line"></span><br><span class="line">args = [<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">x0 = np.array([<span class="number">0.5</span>, <span class="number">0.5</span>, <span class="number">0.5</span>])</span><br><span class="line">res = optimize.minimize(func1(args), x0=x0, constraints=cons1([<span class="number">.1</span>, <span class="number">.9</span>]*<span class="number">3</span>), bounds=bounds)</span><br><span class="line"><span class="built_in">print</span>(res)</span><br><span class="line"></span><br><span class="line"><span class="comment"># res.x = [0.9, 0.9, 0.1</span></span><br><span class="line"><span class="comment"># res.success = True]</span></span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>模型</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Economy</tag>
      </tags>
  </entry>
  <entry>
    <title>NaiveProxy的配置</title>
    <url>/2023/07/16/naiveproxy/</url>
    <content><![CDATA[<p>本文章主要记录一些VPS的设置，使得购买的VPS及域名能够支持科学上网，服务器为Ubuntu 20.04。在执行任何操作之前，切换到<code>/root</code>目录，并使用<code>apt update &amp;&amp; apt upgrade</code>来更新系统。</p>
<span id="more"></span>
<h2 id="事前准备">事前准备</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt install vim git curl wget -y</span><br></pre></td></tr></table></figure>
<p>设置时区 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">timedatectl set-timezone Asia/Shanghai</span><br></pre></td></tr></table></figure></p>
<p>将Cloudflare中SSL/TLS加密模式设置为<code>完全（严格）</code>。</p>
<p>启用 BBR TCP 拥塞控制算法： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;net.core.default_qdisc=fq&quot;</span> &gt;&gt; /etc/sysctl.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;net.ipv4.tcp_congestion_control=bbr&quot;</span> &gt;&gt; /etc/sysctl.conf</span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure></p>
<h2 id="设置密钥登陆">设置密钥登陆</h2>
<h3 id="生成密钥">生成密钥</h3>
<p>连接到服务器后，使用<code>ssh-keygen</code>来生成密钥，并把私钥保存到本地。</p>
<p>使用<code>mv /root/.ssh/id_rsa.pub /root/.ssh/authorized_keys</code>更改公钥名称。使用如下命令来更改权限：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 700 ~/.ssh</span><br><span class="line"><span class="built_in">chmod</span> 600 ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure>
<h3 id="修改登录方式">修改登录方式</h3>
<p>使用<code>vim /etc/ssh/sshd_config</code>来修改SSH配置文件，将<code>PasswordAuthentication</code>改为<code>no</code>，将<code>PubkeyAuthentication</code>改为<code>yes</code>，并<code>systemctl restart ssh</code>重启SSH服务。</p>
<h2 id="安装naiveproxy">安装NaiveProxy</h2>
<p>根据项目<a href="https://github.com/klzgrad/naiveproxy">官方地址</a>的介绍进行如下步骤安装。</p>
<h3 id="编译naiveproxy">编译Naiveproxy</h3>
<h4 id="安装go语言环境">安装<code>Go</code>语言环境</h4>
<p>ubantu下使用<code>sudo apt install golang-go</code>指令安装go环境，安装过程没有报错，在使用时无法识别指令。 是因为未完整安装go环境，使用apt安装的版本可能会比较老。使用如下命令安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt-get install software-properties-common</span><br><span class="line">add-apt-repository ppa:longsleep/golang-backports </span><br><span class="line">apt-get update </span><br><span class="line">apt-get install golang-go -y</span><br></pre></td></tr></table></figure>
<p>测试：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go version</span><br></pre></td></tr></table></figure>
<h4 id="安装naiveproxy-1">安装<code>NaiveProxy</code></h4>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go install github.com/caddyserver/xcaddy/cmd/xcaddy@latest</span><br><span class="line">~/go/bin/xcaddy build --with github.com/caddyserver/forwardproxy@caddy2=github.com/klzgrad/forwardproxy@naive</span><br></pre></td></tr></table></figure>
<h3 id="下载预编译naiveproxy">下载预编译Naiveproxy</h3>
<p>在<a href="https://github.com/klzgrad/forwardproxy/releases">下载地址</a>查找最新版的下载地址并复制： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://github.com/path-to-download/caddy-forwardproxy-naive.tar.xz</span><br><span class="line">tar -xvf caddy-forwardproxy-naive.tar.xz</span><br><span class="line"><span class="built_in">mv</span> /root/caddy-forwardproxy-naive/caddy /root/caddy</span><br></pre></td></tr></table></figure></p>
<h3 id="寻找合适的伪装站">寻找合适的伪装站</h3>
<p>示例关键字：intext:登录 Cloudreve</p>
<h3 id="配置naiveproxy">配置<code>NaiveProxy</code></h3>
<p>在编译好的<code>caddy</code>文件所在目录下创建<code>Caddyfile</code>文件，内容如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    order forward_proxy before file_server</span><br><span class="line">    order forward_proxy before reverse_proxy</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">:443, example.com &#123;</span><br><span class="line">    tls me@example.com</span><br><span class="line">    forward_proxy &#123;</span><br><span class="line">        basic_auth user pass <span class="comment"># 设置用户名和密码</span></span><br><span class="line">        hide_ip</span><br><span class="line">        hide_via</span><br><span class="line">        probe_resistance</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># 支持多用户</span></span><br><span class="line">    forward_proxy &#123;</span><br><span class="line">        basic_auth user2 pass2 <span class="comment"># 用户名和密码</span></span><br><span class="line">        hide_ip</span><br><span class="line">        hide_via</span><br><span class="line">        probe_resistance</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># 本地网站（与伪装网站二选一）</span></span><br><span class="line">    file_server &#123;</span><br><span class="line">        root /var/www/html</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment"># 伪装网址</span></span><br><span class="line">    reverse_proxy  https://demo.cloudreve.org  &#123;</span><br><span class="line">        header_up  Host  &#123;upstream_hostport&#125;</span><br><span class="line">        header_up  X-Forwarded-Host  &#123;host&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="运行naiveproxy">运行<code>NaiveProxy</code></h3>
<p>前台运行caddy：<code>./caddy run</code></p>
<p>后台运行caddy：<code>./caddy start</code></p>
<p>停止caddy：<code>./caddy stop</code></p>
<p>重载配置：<code>./caddy reload</code></p>
<h2 id="caddy配置守护进程开机自启">Caddy配置守护进程（开机自启）</h2>
<p>根据<a href="https://github.com/klzgrad/naiveproxy/wiki/Run-Caddy-as-a-daemon">官方文档</a>进行配置。</p>
<h3 id="准备工作">准备工作</h3>
<ul>
<li>Caddy的二进制文件（/root/caddy）</li>
<li>Caddy的配置文件（/root/Caddyfile）</li>
<li>root权限</li>
<li><code>systemctl --version</code> &gt;= 232</li>
</ul>
<h3 id="移动文件">移动文件</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +x /root/caddy</span><br><span class="line"><span class="built_in">mv</span> /root/caddy /usr/bin/</span><br><span class="line"></span><br><span class="line"><span class="built_in">mkdir</span> /etc/caddy</span><br><span class="line"><span class="built_in">mv</span> /root/Caddyfile /etc/caddy/</span><br></pre></td></tr></table></figure>
<p>检查是否有效：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">/usr/bin/caddy run --config /etc/caddy/Caddyfile</span><br></pre></td></tr></table></figure>
<h3 id="创建用户">创建用户</h3>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">groupadd --system caddy</span><br><span class="line">useradd --system \</span><br><span class="line">    --gid caddy \</span><br><span class="line">    --create-home \</span><br><span class="line">    --home-dir /var/lib/caddy \</span><br><span class="line">    --shell /usr/sbin/nologin \</span><br><span class="line">    --comment <span class="string">&quot;Caddy web server&quot;</span> \</span><br><span class="line">    caddy</span><br></pre></td></tr></table></figure>
<h3 id="创建服务文件">创建服务文件</h3>
<p>在<code>/etc/systemd/system/</code>目录下创建<code>caddy.service</code>文件，<code>vim /etc/systemd/system/caddy.service</code>内容如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Caddy</span><br><span class="line">Documentation=https://caddyserver.com/docs/</span><br><span class="line">After=network.target network-online.target</span><br><span class="line">Requires=network-online.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">User=caddy</span><br><span class="line">Group=caddy</span><br><span class="line">ExecStart=/usr/bin/caddy run --environ --config /etc/caddy/Caddyfile</span><br><span class="line">ExecReload=/usr/bin/caddy reload --config /etc/caddy/Caddyfile</span><br><span class="line">TimeoutStopSec=5s</span><br><span class="line">LimitNOFILE=1048576</span><br><span class="line">LimitNPROC=512</span><br><span class="line">PrivateTmp=<span class="literal">true</span></span><br><span class="line">ProtectSystem=full</span><br><span class="line">AmbientCapabilities=CAP_NET_BIND_SERVICE</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>
<h3 id="最后测试">最后测试</h3>
<p>使用<code>systemd</code>启动Caddy服务： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br><span class="line">systemctl <span class="built_in">enable</span> caddy</span><br><span class="line">systemctl start caddy</span><br></pre></td></tr></table></figure></p>
<p>检查当前状态： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl status caddy</span><br></pre></td></tr></table></figure></p>
<p>使用更改的配置文件重新加载： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl reload caddy</span><br></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>coding</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中的重载</title>
    <url>/2019/01/29/python-1-chongzai/</url>
    <content><![CDATA[<h1 id="概述">概述</h1>
<p>重载，即overwrite</p>
<span id="more"></span>
<h1 id="字符串函数重载">字符串函数重载</h1>
<h2 id="repr与str">repr与str</h2>
<p>repr函数用于print函数调用，str则用于str函数调用</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__repr__</span>(<span class="params">self</span>):</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> some string here</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> some string here</span><br></pre></td></tr></table></figure>
<h1 id="内建函数重载">内建函数重载</h1>
<h2 id="部分内建函数">部分内建函数</h2>
<p>__abs__ __len__ __bool__</p>
<h2 id="bool函数重载">bool函数重载</h2>
<p>用于bool函数取值，或if、while等判断中</p>
<ol type="a">
<li>当类内有__bool__(self)函数时，用此函数的返回值作为bool函数的返回值</li>
<li>当不存在__bool__(self)函数时，用__len__(self)的返回值是否为0来作为bool函数的返回值</li>
<li>也不存在__len__(self)函数时，直接返回True</li>
</ol>
<h1 id="运算符重载">运算符重载</h1>
<h2 id="算术运算符重载">算术运算符重载</h2>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">函数</th>
<th style="text-align: center;">表达式</th>
<th style="text-align: center;">说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">__add__(self, rhs)</td>
<td style="text-align: center;">self + rhs</td>
<td style="text-align: center;">加法</td>
</tr>
<tr class="even">
<td style="text-align: center;">__sub__(self, rhs)</td>
<td style="text-align: center;">self - rhs</td>
<td style="text-align: center;">减法</td>
</tr>
<tr class="odd">
<td style="text-align: center;">__mul__(self, rhs)</td>
<td style="text-align: center;">self * rhs</td>
<td style="text-align: center;">乘法</td>
</tr>
<tr class="even">
<td style="text-align: center;">__truediv__(self, rhs)</td>
<td style="text-align: center;">self / rhs</td>
<td style="text-align: center;">除法</td>
</tr>
<tr class="odd">
<td style="text-align: center;">__floordiv__(self, rhs)</td>
<td style="text-align: center;">self // rhs</td>
<td style="text-align: center;">地板除法</td>
</tr>
<tr class="even">
<td style="text-align: center;">__mod__(self, rhs)</td>
<td style="text-align: center;">self % rhs</td>
<td style="text-align: center;">求余</td>
</tr>
<tr class="odd">
<td style="text-align: center;">__pow__(self, rhs)</td>
<td style="text-align: center;">self ** rhs</td>
<td style="text-align: center;">求幂</td>
</tr>
</tbody>
</table>
<h3 id="反向算术运算符重载">反向算术运算符重载</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">函数</th>
<th style="text-align: center;">表达式</th>
<th style="text-align: center;">说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">__radd__(self, lhs)</td>
<td style="text-align: center;">lhs + self</td>
<td style="text-align: center;">加法</td>
</tr>
<tr class="even">
<td style="text-align: center;">__rsub__(self, lhs)</td>
<td style="text-align: center;">lhs - self</td>
<td style="text-align: center;">减法</td>
</tr>
<tr class="odd">
<td style="text-align: center;">__rmul__(self, lhs)</td>
<td style="text-align: center;">lhs * self</td>
<td style="text-align: center;">乘法</td>
</tr>
<tr class="even">
<td style="text-align: center;">...</td>
<td style="text-align: center;">...</td>
<td style="text-align: center;">...</td>
</tr>
</tbody>
</table>
<h3 id="复合赋值算术运算符重载">复合赋值算术运算符重载</h3>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">函数</th>
<th style="text-align: center;">表达式</th>
<th style="text-align: center;">说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">__iadd__(self, rhs)</td>
<td style="text-align: center;">self += rhs</td>
<td style="text-align: center;">自加</td>
</tr>
<tr class="even">
<td style="text-align: center;">__isub__(self, rhs)</td>
<td style="text-align: center;">self -= rhs</td>
<td style="text-align: center;">自减</td>
</tr>
<tr class="odd">
<td style="text-align: center;">__imul__(self, rhs)</td>
<td style="text-align: center;">self *= rhs</td>
<td style="text-align: center;">自乘</td>
</tr>
<tr class="even">
<td style="text-align: center;">...</td>
<td style="text-align: center;">...</td>
<td style="text-align: center;">...</td>
</tr>
</tbody>
</table>
<ol type="a">
<li>若add与iadd同时存在，则对于+=运算优先iadd</li>
<li>若iadd不存在，add存在，则+=运算使用add</li>
</ol>
<h2 id="比较运算符重载">比较运算符重载</h2>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">函数</th>
<th style="text-align: center;">表达式</th>
<th style="text-align: center;">说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">__lt__(self, num)</td>
<td style="text-align: center;">self &lt; num</td>
<td style="text-align: center;">小于，less than</td>
</tr>
<tr class="even">
<td style="text-align: center;">__le__(self, num)</td>
<td style="text-align: center;">self &lt;= num</td>
<td style="text-align: center;">小于等于，less equal</td>
</tr>
<tr class="odd">
<td style="text-align: center;">__gt__(self, num)</td>
<td style="text-align: center;">self &gt; num</td>
<td style="text-align: center;">大于，greater than</td>
</tr>
<tr class="even">
<td style="text-align: center;">__ge__(self, num)</td>
<td style="text-align: center;">self &gt;= num</td>
<td style="text-align: center;">大于等于</td>
</tr>
<tr class="odd">
<td style="text-align: center;">__eq__(self, num)</td>
<td style="text-align: center;">self == num</td>
<td style="text-align: center;">等于</td>
</tr>
<tr class="even">
<td style="text-align: center;">__ne__(self, num)</td>
<td style="text-align: center;">self != num</td>
<td style="text-align: center;">不等</td>
</tr>
</tbody>
</table>
<h2 id="in运算符重载">in运算符重载</h2>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">函数</th>
<th style="text-align: center;">表达式</th>
<th style="text-align: center;">说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">__contains__(self, v)</td>
<td style="text-align: center;">v in self</td>
<td style="text-align: center;">成员运算</td>
</tr>
</tbody>
</table>
<h2 id="索引及切片运算符重载">索引及切片运算符重载</h2>
<table>
<thead>
<tr class="header">
<th style="text-align: center;">函数</th>
<th style="text-align: center;">表达式</th>
<th style="text-align: center;">说明</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: center;">__getitem__(self, i)</td>
<td style="text-align: center;">self[i]</td>
<td style="text-align: center;">索引取值</td>
</tr>
<tr class="even">
<td style="text-align: center;">__setitem__(self, i, val)</td>
<td style="text-align: center;">self[i] = val</td>
<td style="text-align: center;">索引赋值</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>技巧</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Python中的迭代</title>
    <url>/2019/01/29/python-2-iteration/</url>
    <content><![CDATA[<h1 id="概述">概述</h1>
<p>本文记录遇到的部分迭代技巧</p>
<span id="more"></span>
<h1 id="迭代工具函数">迭代工具函数</h1>
<p>其作用是生成可迭代对象</p>
<h2 id="zipiter1-iter2-...">zip(iter1, iter2, ...)</h2>
<p>返回一个zip对象，此对象可以生成一个元组，其中的元素分别由iter1、iter2、...等中的元素组成，且该元组的长度由最小的可迭代对象决定</p>
<h2 id="enumerateiter-start0">enumerate(iter, start=0)</h2>
<p>生成带索引的枚举对象，默认索引值从0开始，也可指定一个值</p>
<h2 id="代码示例">代码示例</h2>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">nums = [<span class="number">110</span>, <span class="number">120</span>, <span class="number">119</span>, <span class="number">911</span>]</span><br><span class="line">names = [<span class="string">&#x27;警察&#x27;</span>, <span class="string">&#x27;医院&#x27;</span>, <span class="string">&#x27;消防&#x27;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> thing <span class="keyword">in</span> <span class="built_in">zip</span>(nums, names):</span><br><span class="line">    <span class="built_in">print</span>(thing)</span><br><span class="line"></span><br><span class="line">&gt; (<span class="number">110</span>, <span class="string">&#x27;警察&#x27;</span>)</span><br><span class="line">&gt; (<span class="number">120</span>, <span class="string">&#x27;医院&#x27;</span>)</span><br><span class="line">&gt; (<span class="number">119</span>, <span class="string">&#x27;火警&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> ph, name <span class="keyword">in</span> <span class="built_in">zip</span>(nums, names):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;&#123;0&#125;的电话是：&#123;1&#125;&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">str</span>(name), <span class="built_in">str</span>(ph)))</span><br><span class="line"></span><br><span class="line">&gt; 警察的电话是：<span class="number">110</span></span><br><span class="line">&gt; 医院的电话是：<span class="number">120</span></span><br><span class="line">&gt; 火警的电话是：<span class="number">119</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> thing <span class="keyword">in</span> <span class="built_in">zip</span>(<span class="built_in">range</span>(<span class="number">2</span>), nums, names):</span><br><span class="line">    <span class="built_in">print</span>(thing)</span><br><span class="line"></span><br><span class="line">&gt; (<span class="number">0</span>, <span class="number">110</span>, <span class="string">&#x27;警察&#x27;</span>)</span><br><span class="line">&gt; (<span class="number">1</span>, <span class="number">120</span>, <span class="string">&#x27;医院&#x27;</span>)</span><br><span class="line"></span><br><span class="line">d = <span class="built_in">dict</span>(<span class="built_in">zip</span>(nums, names)) <span class="comment"># 可组成字典</span></span><br><span class="line"><span class="built_in">print</span>(d)</span><br><span class="line"></span><br><span class="line">&gt; &#123;<span class="number">110</span>:<span class="string">&#x27;警察&#x27;</span>, <span class="number">120</span>:<span class="string">&#x27;医院&#x27;</span>, <span class="number">119</span>:<span class="string">&#x27;火警&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> thing <span class="keyword">in</span> <span class="built_in">enumerate</span>(names):</span><br><span class="line">    <span class="built_in">print</span>(thing)</span><br><span class="line"></span><br><span class="line">&gt; (<span class="number">0</span>, <span class="string">&#x27;警察&#x27;</span>)</span><br><span class="line">&gt; (<span class="number">1</span>, <span class="string">&#x27;医院&#x27;</span>)</span><br><span class="line">&gt; (<span class="number">2</span>, <span class="string">&#x27;火警&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> thing <span class="keyword">in</span> <span class="built_in">enumerate</span>(names, <span class="number">100</span>):</span><br><span class="line">    <span class="built_in">print</span>(thing)</span><br><span class="line"></span><br><span class="line">&gt; (<span class="number">100</span>, <span class="string">&#x27;警察&#x27;</span>)</span><br><span class="line">&gt; (<span class="number">101</span>, <span class="string">&#x27;医院&#x27;</span>)</span><br><span class="line">&gt; (<span class="number">102</span>, <span class="string">&#x27;火警&#x27;</span>)</span><br></pre></td></tr></table></figure>
<h1 id="yield函数">yield函数</h1>
<h2 id="一个例子斐波那契数列">一个例子：斐波那契数列</h2>
<p><a href="https://baike.baidu.com/item/斐波那契数列">斐波那契数列</a>（Fibonacci）是这样一个数列，其任意一个数等于该数前两个数的和。</p>
<h2 id="斐波那契数列的简单实现">斐波那契数列的简单实现</h2>
<p>一般可用如下代码实现该数列：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fibonacci</span>(<span class="params">num</span>):</span><br><span class="line">    n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; num:</span><br><span class="line">        <span class="built_in">print</span>(b)</span><br><span class="line">	a, b = b, a + b</span><br><span class="line">	n += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">fibonacci(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">&gt; <span class="number">1</span></span><br><span class="line">&gt; <span class="number">1</span></span><br><span class="line">&gt; <span class="number">2</span></span><br><span class="line">&gt; <span class="number">3</span></span><br><span class="line">&gt; <span class="number">5</span></span><br></pre></td></tr></table></figure>
<h2 id="斐波那契数列实现的进一步讨论">斐波那契数列实现的进一步讨论</h2>
<p>对于上面的实现函数，其实用性较差，因为这里直接print出数字，其返回值为None。其他函数无法获得该函数生成的数列。</p>
<p>因此，我们可以改进该函数，使其返回一个list：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fabonacci</span>(<span class="params">num</span>):</span><br><span class="line">    n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">while</span> n &lt; num:</span><br><span class="line">        result.append(b)</span><br><span class="line">	a, b = b, a + b</span><br><span class="line">	n += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">fab = fabonacci(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> fab:</span><br><span class="line">    <span class="built_in">print</span>(n)</span><br><span class="line"></span><br><span class="line">&gt; <span class="number">1</span></span><br><span class="line">&gt; <span class="number">1</span></span><br><span class="line">&gt; <span class="number">2</span></span><br><span class="line">&gt; <span class="number">3</span></span><br><span class="line">&gt; <span class="number">5</span></span><br></pre></td></tr></table></figure>
<h2 id="使用yield函数改进">使用yield函数改进</h2>
<p>对于上面的改进版本，当传入的参数num的值很大时，其生成的list也很大，很占内存。要进一步改进，我们可以用迭代器，不用list保存中间结果，而是用iterable对象来迭代。可以通过写一个类，重载该类的__iter__函数和__next__函数来实现。</p>
<p>但这样显然十分繁琐，yield函数就提供了这样一种功能：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fabonacci</span>(<span class="params">num</span>):</span><br><span class="line">    n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; num:</span><br><span class="line">        <span class="keyword">yield</span> b</span><br><span class="line">	a, b = b, a + b</span><br><span class="line">	n += <span class="number">1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> fabonacci(<span class="number">5</span>):</span><br><span class="line">    <span class="built_in">print</span>(n)</span><br><span class="line"></span><br><span class="line">&gt; <span class="number">1</span></span><br><span class="line">&gt; <span class="number">1</span></span><br><span class="line">&gt; <span class="number">2</span></span><br><span class="line">&gt; <span class="number">3</span></span><br><span class="line">&gt; <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>仅仅通过把print(b)改成yield b就可以了，十分的简洁、高效。</p>
<p>一个带有yield的函数就是一个generator。这样的函数与普通函数的不同在于，对该函数进行调用时不会执行任何函数代码，直到对其调用next才开始执行（for循环中自动调用next）。</p>
<h2 id="yield的另一个应用场景">yield的另一个应用场景</h2>
<p>文件读取时，若直接对文件对象使用read()函数，会导致不可预测的内存占用。可以通过设定一定大小的缓冲区来不断读取文件内容：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">read_file</span>(<span class="params">file_path, block_size=<span class="number">1024</span></span>):</span><br><span class="line">    <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">	    block = f.read(block_size)</span><br><span class="line">	    <span class="keyword">if</span> block:</span><br><span class="line">	        <span class="keyword">yield</span> block</span><br><span class="line">	    <span class="keyword">else</span>:</span><br><span class="line">	        <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>技巧</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>给Ubuntu配置运行CUDA的Docker</title>
    <url>/2024/06/04/ubuntu-docker-cuda/</url>
    <content><![CDATA[<p>建议使用<code>Ubuntu 20.04</code>以上的版本。</p>
<span id="more"></span>
<h1 id="安装cuda-toolkit">安装Cuda Toolkit</h1>
<h2 id="ubuntu-20.04">Ubuntu 20.04+</h2>
<p>注意，随Cuda的升级，下面的命令可能会发生改变，具体命令<a href="https://developer.nvidia.com/cuda-downloads?target_os=Linux&amp;target_arch=x86_64&amp;Distribution=Ubuntu&amp;target_version=22.04&amp;target_type=deb_network">查看此链接</a>。 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://developer.download.nvidia.com/compute/cuda/repos/ubuntu2004/x86_64/cuda-keyring_1.1-1_all.deb</span><br><span class="line"><span class="built_in">sudo</span> dpkg -i cuda-keyring_1.1-1_all.deb</span><br><span class="line"><span class="built_in">sudo</span> apt-get update</span><br><span class="line"><span class="built_in">sudo</span> apt-get -y install cuda-toolkit-12-5</span><br></pre></td></tr></table></figure></p>
<h2 id="ubuntu-18.04">Ubuntu 18.04</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://developer.download.nvidia.com/compute/cuda/repos/ubuntu1804/x86_64/cuda-keyring_1.0-1_all.deb</span><br><span class="line"><span class="built_in">sudo</span> dpkg -i cuda-keyring_1.0-1_all.deb</span><br><span class="line"><span class="built_in">sudo</span> apt-get update</span><br><span class="line"><span class="built_in">sudo</span> apt-get -y install cuda</span><br></pre></td></tr></table></figure>
<h2 id="重启">重启</h2>
<p>安装CUda Toolkit后要重启系统<code>sudo reboot</code>。</p>
<h1 id="安装docker">安装Docker</h1>
<h2 id="配置docker的repo">配置Docker的repo</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get update</span><br><span class="line"><span class="built_in">sudo</span> apt-get install ca-certificates curl</span><br><span class="line"><span class="built_in">sudo</span> install -m 0755 -d /etc/apt/keyrings</span><br><span class="line"><span class="built_in">sudo</span> curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chmod</span> a+r /etc/apt/keyrings/docker.asc</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> \</span><br><span class="line">  <span class="string">&quot;deb [arch=<span class="subst">$(dpkg --print-architecture)</span> signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \</span></span><br><span class="line"><span class="string">  <span class="subst">$(. /etc/os-release &amp;&amp; echo <span class="string">&quot;<span class="variable">$VERSION_CODENAME</span>&quot;</span>)</span> stable&quot;</span> | \</span><br><span class="line">  <span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br><span class="line"><span class="built_in">sudo</span> apt-get update</span><br></pre></td></tr></table></figure>
<h2 id="安装docker-1">安装Docker</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</span><br><span class="line"><span class="built_in">sudo</span> usermod <span class="variable">$USER</span> -aG docker <span class="comment"># 添加本用户到docker的组中</span></span><br><span class="line"><span class="built_in">sudo</span> service docker start</span><br></pre></td></tr></table></figure>
<p>要确认Docker成功安装，输入命令<code>docker --version</code>查看输出，还可以通过尝试运行<code>docker run hello-world</code>运行简单的内置Docker映像，测试安装是否正常工作。</p>
<h1 id="给docker配置cuda">给Docker配置CUDA</h1>
<h2 id="安装nvidia-container-toolkit">安装NVIDIA Container Toolkit</h2>
<p>首先配置repo： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://nvidia.github.io/libnvidia-container/gpgkey | <span class="built_in">sudo</span> gpg --dearmor -o /usr/share/keyrings/nvidia-container-toolkit-keyring.gpg \</span><br><span class="line">  &amp;&amp; curl -s -L https://nvidia.github.io/libnvidia-container/stable/deb/nvidia-container-toolkit.list | \</span><br><span class="line">    sed <span class="string">&#x27;s#deb https://#deb [signed-by=/usr/share/keyrings/nvidia-container-toolkit-keyring.gpg] https://#g&#x27;</span> | \</span><br><span class="line">    <span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/apt/sources.list.d/nvidia-container-toolkit.list</span><br></pre></td></tr></table></figure> 然后更新repo<code>sudo apt-get update</code>，再运行<code>sudo apt-get install -y nvidia-container-toolkit</code>来安装NVIDIA Container Toolkit。</p>
<h2 id="配置docker">配置Docker</h2>
<p>使用<code>nvidia-ctk</code>命令配置容器运行时： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nvidia-ctk runtime configure --runtime=docker</span><br></pre></td></tr></table></figure></p>
<p>重新启动Docker进程： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl restart docker</span><br></pre></td></tr></table></figure></p>
<h2 id="测试">测试</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --<span class="built_in">rm</span> --runtime=nvidia --gpus all ubuntu nvidia-smi</span><br><span class="line">docker run --gpus all nvcr.io/nvidia/k8s/cuda-sample:nbody nbody -gpu -benchmark</span><br></pre></td></tr></table></figure>
<p>若测试失败，则<code>sudo vim /etc/nvidia-container-runtime/config.toml</code>，然后修改<code>no-cgroups = false</code>，再重启Docker。 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl restart docker</span><br><span class="line">docker run --gpus all nvcr.io/nvidia/k8s/cuda-sample:nbody nbody -gpu -benchmark</span><br></pre></td></tr></table></figure></p>
<h1 id="给docker配置proxy">给Docker配置proxy</h1>
<p><a href="https://askubuntu.com/questions/1098849/docker-image-build-command-fails-with-client-timeout-exceeded-while-awaiting-h">参考链接</a></p>
<ol type="1">
<li><a href="https://docs.docker.com/config/daemon/systemd/#httphttps-proxy">给daemon配置proxy</a></li>
<li><a href="https://docs.docker.com/network/proxy/">给client配置proxy</a></li>
</ol>
<h2 id="让docker-build使用本机proxy">让<code>Docker build</code>使用本机proxy</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build --network=host --build-arg http_proxy=<span class="variable">$http_proxy</span> --build-arg https_proxy=<span class="variable">$https_proxy</span> ...</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>coding</tag>
        <tag>Ubuntu</tag>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>给Nvidia显卡的电脑安装Ubuntu</title>
    <url>/2024/09/06/ubuntu-nvidia/</url>
    <content><![CDATA[<p>下载安装介质后，进入安装介质可能会黑屏，要在选择<code>Try or install ubuntu</code>时按<code>e</code>进入编辑模式，在<code>--- quite splash</code>删除<code>---</code>并添加<code>nomodeset</code>，然后按<code>F10</code>进入安装介质。</p>
<span id="more"></span>
<h1 id="配置ubuntu">配置Ubuntu</h1>
<p>安装完成后，在进入系统前，同样在<code>quite splash</code>后添加<code>nomodeset</code>，并按<code>F10</code>进入系统。</p>
<h2 id="安装nvidia驱动">安装Nvidia驱动</h2>
<p><a href="https://documentation.ubuntu.com/server/how-to/graphics/install-nvidia-drivers/">参考文献</a>。</p>
<p>首先输入<code>sudo ubuntu-drivers list</code>查看可以安装的驱动及其版本，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nvidia-driver-470</span><br><span class="line">nvidia-driver-470-server</span><br><span class="line">nvidia-driver-535</span><br><span class="line">nvidia-driver-535-open</span><br><span class="line">nvidia-driver-535-server</span><br><span class="line">nvidia-driver-535-server-open</span><br><span class="line">nvidia-driver-550</span><br><span class="line">nvidia-driver-550-open</span><br><span class="line">nvidia-driver-550-server</span><br><span class="line">nvidia-driver-550-server-open</span><br></pre></td></tr></table></figure>
<p>一般安装专用驱动，输入<code>sudo ubuntu-drivers install nvidia:550</code>，然后重启，不用再输入<code>nomodeset</code>。</p>
<p>重启后输入<code>nvidia-smi</code>检查。</p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>coding</tag>
        <tag>ubuntu</tag>
        <tag>ML</tag>
      </tags>
  </entry>
  <entry>
    <title>给WSL2配置运行CUDA的Docker</title>
    <url>/2024/06/03/wsl-docker/</url>
    <content><![CDATA[<p>注意，本文使用<code>WSL2</code>+<code>Docker</code>，而不是安装<code>Docker Desktop for Windows</code>，因为后者占用的资源非常多，而且还有很多bug，比如，<a href="https://github.com/docker/for-win/issues/13870">GPU无法运行</a>。</p>
<span id="more"></span>
<h1 id="安装wsl">安装WSL</h1>
<p>运行一下命令将安装WSL并安装Ubuntu发行版，如果需要安装其他Linux发行版（如Arch Linux），请参考<a href="https://learn.microsoft.com/zh-cn/windows/wsl/install">此链接</a>。</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line">wsl <span class="literal">--install</span></span><br></pre></td></tr></table></figure>
<h2 id="常用wsl命令">常用WSL命令</h2>
<ul>
<li>列出WSL子系统: <code>wsl --list</code></li>
<li>关闭WSL：<code>wsl --shutdown</code></li>
<li>WSL配置文件：<code>C:/users/YOUR_NAME/.wslconfig</code></li>
</ul>
<blockquote>
<p><strong>Notes</strong></p>
<p>让WSL使用本机的代理，编写<code>.wslconfig</code>如下： <figure class="highlight txt"><table><tr><td class="code"><pre><span class="line">[wsl2]</span><br><span class="line">networkingMode=mirrored</span><br><span class="line">dnsTunneling=true</span><br><span class="line">autoProxy=true</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h1 id="安装docker">安装Docker</h1>
<h2 id="配置docker的repo">配置Docker的repo</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get update</span><br><span class="line"><span class="built_in">sudo</span> apt-get install ca-certificates curl</span><br><span class="line"><span class="built_in">sudo</span> install -m 0755 -d /etc/apt/keyrings</span><br><span class="line"><span class="built_in">sudo</span> curl -fsSL https://download.docker.com/linux/ubuntu/gpg -o /etc/apt/keyrings/docker.asc</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">chmod</span> a+r /etc/apt/keyrings/docker.asc</span><br><span class="line"></span><br><span class="line"><span class="built_in">echo</span> \</span><br><span class="line">  <span class="string">&quot;deb [arch=<span class="subst">$(dpkg --print-architecture)</span> signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/ubuntu \</span></span><br><span class="line"><span class="string">  <span class="subst">$(. /etc/os-release &amp;&amp; echo <span class="string">&quot;<span class="variable">$VERSION_CODENAME</span>&quot;</span>)</span> stable&quot;</span> | \</span><br><span class="line">  <span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/apt/sources.list.d/docker.list &gt; /dev/null</span><br><span class="line"><span class="built_in">sudo</span> apt-get update</span><br></pre></td></tr></table></figure>
<h2 id="安装docker-1">安装Docker</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin</span><br><span class="line"><span class="built_in">sudo</span> usermod <span class="variable">$USER</span> -aG docker <span class="comment"># 添加本用户到docker的组中</span></span><br><span class="line"><span class="built_in">sudo</span> service docker start</span><br></pre></td></tr></table></figure>
<p>要确认Docker成功安装，进入WSL的Ubuntu（使用命令<code>wsl</code>），并输入命令<code>docker --version</code>查看输出，还可以通过尝试运行<code>docker run hello-world</code>运行简单的内置Docker映像，测试安装是否正常工作。</p>
<h1 id="给docker配置cuda">给Docker配置CUDA</h1>
<h2 id="安装nvidia-container-toolkit">安装NVIDIA Container Toolkit</h2>
<p>首先配置repo： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">curl -fsSL https://nvidia.github.io/libnvidia-container/gpgkey | <span class="built_in">sudo</span> gpg --dearmor -o /usr/share/keyrings/nvidia-container-toolkit-keyring.gpg \</span><br><span class="line">  &amp;&amp; curl -s -L https://nvidia.github.io/libnvidia-container/stable/deb/nvidia-container-toolkit.list | \</span><br><span class="line">    sed <span class="string">&#x27;s#deb https://#deb [signed-by=/usr/share/keyrings/nvidia-container-toolkit-keyring.gpg] https://#g&#x27;</span> | \</span><br><span class="line">    <span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/apt/sources.list.d/nvidia-container-toolkit.list</span><br></pre></td></tr></table></figure> 然后更新repo<code>sudo apt-get update</code>，再运行<code>sudo apt-get install -y nvidia-container-toolkit</code>来安装NVIDIA Container Toolkit。</p>
<h2 id="配置docker">配置Docker</h2>
<p>使用<code>nvidia-ctk</code>命令配置容器运行时： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> nvidia-ctk runtime configure --runtime=docker</span><br></pre></td></tr></table></figure></p>
<p>重新启动Docker进程： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl restart docker</span><br></pre></td></tr></table></figure></p>
<h2 id="测试">测试</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run --gpus all nvcr.io/nvidia/k8s/cuda-sample:nbody nbody -gpu -benchmark</span><br></pre></td></tr></table></figure>
<h1 id="配置docker-1">配置Docker</h1>
<h2 id="配置iptable">配置iptable</h2>
<p>让WSL中的Ubuntu使用iptable（option 1），否则Docker的NAT会有问题。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">update-alternatives --config iptables</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Ref: https://nickjanetakis.com/blog/install-docker-in-wsl-2-without-docker-desktop</p>
</blockquote>
<h2 id="配置proxy">配置proxy</h2>
<ol type="1">
<li><a href="https://docs.docker.com/config/daemon/systemd/#httphttps-proxy">给daemon配置proxy</a></li>
<li><a href="https://docs.docker.com/network/proxy/">给client配置proxy</a></li>
</ol>
<h2 id="让docker-build使用本机proxy">让<code>Docker build</code>使用本机proxy</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build --network=host --build-arg http_proxy=<span class="variable">$http_proxy</span> --build-arg https_proxy=<span class="variable">$https_proxy</span> ...</span><br></pre></td></tr></table></figure>
<h2 id="docker部分命令">Docker部分命令</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker builder prune -a</span><br></pre></td></tr></table></figure>
<p><a href="https://docs.docker.com/reference/cli/docker/builder/prune/">参考链接</a></p>
]]></content>
      <categories>
        <category>教程</category>
      </categories>
      <tags>
        <tag>coding</tag>
        <tag>Docker</tag>
        <tag>windows</tag>
        <tag>WSL2</tag>
      </tags>
  </entry>
  <entry>
    <title>Xray的配置</title>
    <url>/2023/07/16/xray/</url>
    <content><![CDATA[<p>本文章主要记录一些VPS的设置，使得购买的VPS及域名能够支持科学上网，服务器为Ubuntu 20.04。在执行任何操作之前，切换到<code>/root</code>目录，并使用<code>apt update &amp;&amp; apt upgrade</code>来更新系统。</p>
<span id="more"></span>
<h2 id="事前准备">事前准备</h2>
<h3 id="服务器准备">服务器准备</h3>
<p>部分软件： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt install vim git curl wget -y</span><br></pre></td></tr></table></figure></p>
<p>启用 BBR TCP 拥塞控制算法： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;net.core.default_qdisc=fq&quot;</span> &gt;&gt; /etc/sysctl.conf</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;net.ipv4.tcp_congestion_control=bbr&quot;</span> &gt;&gt; /etc/sysctl.conf</span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure></p>
<p>设置时区： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">timedatectl set-timezone Asia/Shanghai</span><br></pre></td></tr></table></figure></p>
<h3 id="cloudflare准备">Cloudflare准备</h3>
<p>将Cloudflare中SSL/TLS加密模式设置为<code>完全（严格）</code>。</p>
<p>在<a href="https://dash.cloudflare.com/profile/api-tokens">Cloudflare</a>创建一个新的令牌（参考<a href="https://github.com/libdns/cloudflare">cf插件主页</a>配置），权限为<code>Zone.Zone.Read; Zone.DNS.Edit</code>，并将令牌保存到本地。</p>
<p>在<a href="https://caddyserver.com/download?package=github.com%2Fcaddy-dns%2Fcloudflare">Caddy官方下载地址</a>，选择<code>dns.provider.cloudflare</code>，下载到本地准备。</p>
<h2 id="设置密钥登陆">设置密钥登陆</h2>
<h3 id="生成密钥">生成密钥</h3>
<p>连接到服务器后，使用<code>ssh-keygen</code>来生成密钥，并把私钥保存到本地。</p>
<p>使用<code>mv /root/.ssh/id_rsa.pub /root/.ssh/authorized_keys</code>更改公钥名称。使用如下命令来更改权限：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 700 ~/.ssh</span><br><span class="line"><span class="built_in">chmod</span> 600 ~/.ssh/authorized_keys</span><br></pre></td></tr></table></figure>
<h3 id="修改登录方式">修改登录方式</h3>
<p>使用<code>vim /etc/ssh/sshd_config</code>来修改SSH配置文件，将<code>PasswordAuthentication</code>改为<code>no</code>，将<code>PubkeyAuthentication</code>改为<code>yes</code>，并<code>systemctl restart ssh</code>重启SSH服务。</p>
<blockquote>
<p>如有必要，可以更改ssh的端口号，修改<code>Port</code>即可。</p>
</blockquote>
<h2 id="安装caddy">安装Caddy</h2>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">apt install -y debian-keyring debian-archive-keyring apt-transport-https</span><br><span class="line">curl -1sLf <span class="string">&#x27;https://dl.cloudsmith.io/public/caddy/stable/gpg.key&#x27;</span> | <span class="built_in">sudo</span> gpg --dearmor -o /usr/share/keyrings/caddy-stable-archive-keyring.gpg</span><br><span class="line">curl -1sLf <span class="string">&#x27;https://dl.cloudsmith.io/public/caddy/stable/debian.deb.txt&#x27;</span> | <span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/apt/sources.list.d/caddy-stable.list</span><br><span class="line">apt update</span><br><span class="line">apt install caddy</span><br></pre></td></tr></table></figure>
<p>把之前下载的Caddy传到root下， <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> ./caddy_linux_amd64_custom ./caddy</span><br><span class="line"><span class="built_in">chmod</span> +x ./caddy</span><br><span class="line">./caddy list-modules | grep dns</span><br></pre></td></tr></table></figure> 如果正常，会显示出<code>dns.providers.cloudflare</code>模块。</p>
<p>在替换官方的Caddy： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mv</span> ./caddy /usr/bin/caddy</span><br></pre></td></tr></table></figure></p>
<h3 id="寻找合适的伪装站">寻找合适的伪装站</h3>
<p>示例关键字：intext:登录 Cloudreve</p>
<h3 id="配置caddy">配置Caddy</h3>
<p>启动Caddy服务： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">systemctl <span class="built_in">enable</span> --now caddy</span><br></pre></td></tr></table></figure></p>
<p>通过如下命令查看Caddy的日志： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">journalctl -u caddy --no-pager | less +G</span><br></pre></td></tr></table></figure></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vim /etc/caddy/Caddyfile</span><br></pre></td></tr></table></figure>
<p>改为如下： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">example.com &#123;</span><br><span class="line">    encode gzip</span><br><span class="line"></span><br><span class="line">    tls &#123;</span><br><span class="line">        dns cloudflare 你的API token</span><br><span class="line">        protocols tls1.2 tls1.3</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    reverse_proxy /rayws* localhost:port &#123;</span><br><span class="line">        header_up Host &#123;host&#125;</span><br><span class="line">        header_up X-Real-IP &#123;remote_host&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    reverse_proxy /xuiws* localhost:port</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 伪装网址</span></span><br><span class="line">    reverse_proxy https://demo.cloudreve.org &#123;</span><br><span class="line">        header_up Host &#123;upstream_hostport&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>奇怪的是xui只能在Chrome匿名模式下进入</p>
</blockquote>
<p><code>caddy run</code>查看tls是否生效： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">tls.obtain      certificate obtained successfully</span><br></pre></td></tr></table></figure></p>
<h2 id="xui">XUI</h2>
<h3 id="安装xui">安装XUI</h3>
<p>参考<a href="https://github.com/FranzKafkaYu/x-ui">官方仓库</a>： <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bash &lt;(curl -Ls https://raw.githubusercontent.com/FranzKafkaYu/x-ui/master/install.sh)</span><br></pre></td></tr></table></figure></p>
<h3 id="配置xui">配置XUI</h3>
<p>进入面板，把监听IP改为<code>127.0.0.1</code>，端口改为上面定义的<code>xuiws</code>端口。添加端口为<code>rayws</code>端口的节点。</p>
]]></content>
      <categories>
        <category>记录</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>coding</tag>
      </tags>
  </entry>
</search>
